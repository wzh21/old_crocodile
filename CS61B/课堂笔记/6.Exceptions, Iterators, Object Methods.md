# 6.1 Lists, Sets, ArraySet

In this section we will learn about how to use Java's built in `List` and `Set` data structures as well as build our own `ArraySet`.**在本节中，我们将学习如何使用Java内置的“`List`”和“`Set`”数据结构以及构建自己的“`ArraySet`”。**

在本课程中，我们已经构建了两种列表：“`AList`”和“`SLList`”。我们还构建了一个接口“`List61B`”，以强制执行“`AList`”和“`SLList`”必须实现的特定列表方法。您可以在以下链接中找到代码：

- [List61B](https://github.com/Berkeley-CS61B/lectureCode-sp19/blob/master/inheritance2/List61B.java)
- [AList](https://github.com/Berkeley-CS61B/lectureCode-sp19/blob/master/inheritance1/AList.java)
- [SLList](https://github.com/Berkeley-CS61B/lectureCode-sp19/blob/master/inheritance2/SLList.java)

This is how we might use `List61B` type:

```java
List61B<Integer> L = new AList<>();
L.addLast(5);
L.addLast(10);
L.addLast(15);
L.print();
```

## Lists in Real Java Code

我们从头开始构建了一个列表，但Java提供了一个内置的list接口和几个实现，例如ArrayList。记住，**因为List是一个接口，所以我们不能初始化它！我们必须实现它的一个实现。**

To access this, we can use the full name ('canonical name') of classes, interfaces:

```java
java.util.List<Integer> L = new java.util.ArrayList<>();
```

However this is a bit verbose(冗长). In a similar way to how we import `JUnit`, we can import java libraries:

```java
import java.util.List;
import java.util.ArrayList;

public class Example {
    public static void main(String[] args) {
        List<Integer> L = new ArrayList<>();
        L.add(5);
        L.add(10);
        System.out.println(L);
    }
}
```

## Sets

> set是集合, 和数学上的集合有相同的特性 1.无序 2.元素唯一

#### Java

Java具有“`Set`”接口以及实现，例如“`HashSet`”。如果您不想使用全名，请记住导入它们！

```java
import java.util.Set;
import java.util.HashSet;
```

Example use:

```java
Set<String> s = new HashSet<>();
s.add("Tokyo");
s.add("Lagos");
System.out.println(S.contains("Tokyo")); // true
```

#### Python

In python, we simply call `set()`. To check for `contains` we don't use a method but the keyword `in`.

```python
s = set()
s.add("Tokyo")
s.add("Lagos")
print("Tokyo" in s) // True
```

## ArraySet

Our goal is to make our own set, `ArraySet`, with the following methods:

- `add(value)`: add the value to the set if not already present
- `contains(value)`: check to see if ArraySet contains the key
- `size()`: return number of values

If you would like to try it yourself, find 'Do It Yourself' [starter code here](https://github.com/Berkeley-CS61B/lectureCode-sp19/blob/af2325c600010a8894a6ce3a3ccf517547145ec1/exercises/DIY/inheritance4/ArraySet.java). In the lecture clip below, Professor Hug goes develops the solution:

Here is our code as of now:

```java
import java.util.Iterator;

public class ArraySet<T> implements Iterable<T> {
    private T[] items;
    private int size; // the next item to be added will be at position size

    public ArraySet() {
        items = (T[]) new Object[100];
        size = 0;
    }

    /* Returns true if this map contains a mapping for the specified key.
     */
    public boolean contains(T x) {
        for (int i = 0; i < size; i += 1) {
            if (items[i].equals(x)) {
                return true;
            }
        }
        return false;
    }

    /* Associates the specified value with the specified key in this map. */
    public void add(T x) {
        if (contains(x)) {
            return;
        }
        items[size] = x;
        size += 1;
    }

    /* Returns the number of key-value mappings in this map. */
    public int size() {
        return size;
    }
}
```

# 6.2 Throwing Exceptions

上一节中的“`ArraySet`”实现有一个小错误。当我们将“`null`”添加到ArraySet时，我们会得到一个NullPointerException。

The probelm lies in the `contains` method where we check `items[i].equals(x)`. If the value at `items[i]` is null, then we are calling `null.equals(x)` -> NullPointerException.

异常导致正常控制流停止。事实上，我们可以选择抛出自己的异常。在python中，您可能已经看到了“`raise`”关键字。在Java中，异常是对象，我们使用以下格式抛出异常：

```
throw new ExceptionObject(parameter1, ...)
```

Let's throw an exception when a user tries to add null to our `ArraySet`. We'll throw an `IllegalArgumentException` which takes in one parameter (a `String` message).

Our updated `add` method:

```java
/* Associates the specified value with the specified key in this map.
   Throws an IllegalArgumentException if the key is null. */
public void add(T x) {
    if (x == null) {
        throw new IllegalArgumentException("can't add null");
    }
    if (contains(x)) {
        return;
    }
    items[size] = x;
    size += 1;
}
```

**We get an Exception either way - why is this better?**

1. We have control of our code: we consciously decide at what point to stop the flow of our program**我们可以控制代码：我们有意识地决定在什么时候停止程序的运行**
2. More useful Exception type and helpful error message for those using our code**对于使用我们代码的人来说，更有用的异常类型和有用的错误消息**

However, it would be better if the program doesn't crash at all. There are different things we could do in this case. Here are some below:

**Approach 1**: Don't add `null` to the array if it is passed into `add` **Approach 2**: Change the `contains` method to account for the case if `items[i] == null`.

**无论你做什么决定，重要的是让用户知道期望是什么。这就是为什么文档（如对方法的评论）非常重要的原因**。

# 6.3 Iteration

We can use a clean enhanced for loop with Java's `HashSet`

```java
Set<String> s = new HashSet<>();
s.add("Tokyo");
s.add("Lagos");
for (String city : s) {
    System.out.println(city);
}
```

但是，如果我们尝试对“`ArraySet`”执行同样的操作，就会出现错误。我们如何启用此功能？

## Enhanced For Loop

让我们先了解一下当我们使用增强的for循环时会发生什么。我们可以将增强的for循环“转化”为丑陋的手动方法。

```java
Set<String> s = new HashSet<>();
...
for (String city : s) {
    ...
}
```

The above code translates to:

```java
Set<String> s = new HashSet<>();
...
Iterator<String> seer = s.iterator();
while (seer.hasNext()) {
    String city = seer.next();
    ...
}
```

> ==**上面的那个enhanced loop就是下面这个的简洁版, **==

让我们去掉魔法，这样我们就可以构建自己的类来支持这一点。

**The key here is an object called an *iterator***.这里的关键是一个名为*迭代器*的对象。

For our example, in List.java we might define an `iterator()` method that returns an iterator object.

```java
public Iterator<E> iterator();
```

Now, we can use that object to loop through all the entries in our list: 现在，我们可以使用该对象循环遍历列表中的所有条目：

```java
List<Integer> friends = new ArrayList<Integer>();
...
Iterator<Integer> seer = friends.iterator();

while (seer.hasNext()) {
System.out.println(seer.next());
}
```

This code behaves identically to the foreach loop version above.此代码的行为与上述foreach循环版本相同。

There are three key methods in our iterator approach:迭代器方法有三个关键方法：

**First, we get a new iterator object with `Iterator<Integer> seer = friends.iterator();`**

**Next, we loop through the list with our while loop. We check that there are still items left with `seer.hasNext()`, which will return true if there are unseen items remaining, and false if all items have been processed.**

**Last, `seer.next()` does two things at once. It returns the next element of the list, and here we print it out. It also advances the iterator by one item. In this way, the iterator will only inspect each item once.**

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230125181812116.png" alt="image-20230125181812116" style="zoom:20%;" /><img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230125181826594.png" alt="image-20230125181826594" style="zoom:20%;" />

## Implementing Iterators

在本节中，我们将讨论如何构建支持迭代的类。

让我们首先思考编译器需要知道什么才能成功编译以下迭代器示例：

```java
List<Integer> friends = new ArrayList<Integer>();
Iterator<Integer> seer = friends.iterator();

while(seer.hasNext()) {
    System.out.println(seer.next());
}
```

We can look at the static types of each object that calls a relevant method. `friends` is a List, on which `iterator()` is called, so we must ask:

- **Does the List interface have an iterator() method?**

`seer` is an Iterator, on which `hasNext()` and `next()` are called, so we must ask:

- **Does the Iterator interface have next/hasNext() methods?**

So how do we implement these requirements?

The List interface extends the Iterable interface, inheriting the abstract iterator() method. **(Actually, List extends Collection which extends Iterable, but it's easier to codethink of this way to start.)**

```java
public interface Iterable<T> {
    Iterator<T> iterator();
}
public interface List<T> extends Iterable<T>{
    ...
}
```

Next, the compiler checks that Iterators have `hasNext()` and `next()`. The Iterator interface specifies these abstract methods explicitly:

```java
public interface Iterator<T> {
    boolean hasNext();
    T next();
}
```

##### What if someone calls `next` when `hasNext` returns false?

> This behavior is undefined. However, a common convention is to throw a `NoSuchElementException` **此行为未定义。然而，一个常见的约定是抛出`NoSuchElementException`.** See [Discussion 5](https://sp19.datastructur.es/materials/discussion/disc05sol.pdf) for examples.

##### Will `hasNext` always be called before `next`?

> Not necessarily. This is sometimes the case when someone using the iterator knows exactly how many elements are in the sequence. Thus, we can't rely on the user calling `hasNext` before `next`. However, you can always call `hasNext` from within your `next` function.

特定类将为接口方法实现自己的迭代行为。让我们看一个例子。（注意：如果你想从一开始就建立起来，请跟随视频中的实时编码。）

我们将通过键向ArrayMap类添加迭代。首先，我们编写一个名为`ArraySetIterator`的新类，嵌套在ArraySet内部：

```java
private class ArraySetIterator implements Iterator<T> {
    private int wizPos;

    public ArraySetIterator() {
        wizPos = 0;
    }

    public boolean hasNext() {
        return wizPos < size;
    }

    public T next() {
        T returnItem = items[wizPos];
        wizPos += 1;
        return returnItem;
    }
}
```

This ArraySetIterator implements a `hasNext()` method, and a `next()` method, using a `wizPos` position as an index to keep track of its position in the array. For a different data structure, we might implement these two methods differently.

**Thought Excercise:** How would you design `hasNext()` and `next()` for a linked list?

Now that we have the appropriate methods, we could use a ArraySetIterator to iterate through an ArrayMap:

```java
ArraySet<Integer> aset = new ArraySet<>();
aset.add(5);
aset.add(23);
aset.add(42);

Iterator<Integer> iter = aset.iterator();

while(iter.hasNext()) {
    System.out.println(iter.next());
}
```

We still want to be able to support the enhanced for loop, though, to make our calls cleaner. So, we need to make ArrayMap implement the Iterable interface. The essential method of the Iterable interface is `iterator()`, which returns an Iterator object for that class. All we have to do is return an instance of our `ArraySetIterator` that we just wrote!

```java
public Iterator<T> iterator() {
    return new ArraySetIterator();
}
```

Now we can use enhanced for loops with our `ArrraySet`!

```java
ArraySet<Integer> aset = new ArraySet<>();
...
for (int i : aset) {
    System.out.println(i);
}
```

Here we've seen **Iterable**, the interface that makes a class able to be iterated on, and requires the method `iterator()`, which returns an Iterator object. And we've seen **Iterator**, the interface that defines the object with methods to actually do that iteration. You can think of an Iterator as a machine that you put onto an iterable that facilitates the iteration. Any iterable is the object on which the iterator is performing.

With these two components, you can make fancy for loops for your classes!

`ArraySet` code with iteration support is below:

> **要告诉编译器,我有iterable方法,所以要implement Iterable, 并实现方法**
>
> **==注意, 一个是`Iterable`, 一个是`Iterator`  (可迭代和迭代器)==**

```java
import java.util.Iterator;

public class ArraySet<T> implements Iterable<T> {
    private T[] items;
    private int size; // the next item to be added will be at position size

    public ArraySet() {
        items = (T[]) new Object[100];
        size = 0;
    }

    /* Returns true if this map contains a mapping for the specified key.
     */
    public boolean contains(T x) {
        for (int i = 0; i < size; i += 1) {
            if (items[i].equals(x)) {
                return true;
            }
        }
        return false;
    }

    /* Associates the specified value with the specified key in this map.
       Throws an IllegalArgumentException if the key is null. */
    public void add(T x) {
        if (x == null) {
            throw new IllegalArgumentException("can't add null");
        }
        if (contains(x)) {
            return;
        }
        items[size] = x;
        size += 1;
    }

    /* Returns the number of key-value mappings in this map. */
    public int size() {
        return size;
    }

    /** returns an iterator (a.k.a. seer) into ME */
    public Iterator<T> iterator() {
        return new ArraySetIterator();
    }

    private class ArraySetIterator implements Iterator<T> {
        //嵌套类,惯例如此
        private int wizPos;

        public ArraySetIterator() {
            wizPos = 0;
        }

        public boolean hasNext() {
            return wizPos < size;
        }

        public T next() {
            T returnItem = items[wizPos];
            wizPos += 1;
            return returnItem;
        }
    }

    public static void main(String[] args) {
        ArraySet<Integer> aset = new ArraySet<>();
        aset.add(5);
        aset.add(23);
        aset.add(42);

        //iteration
        for (int i : aset) {
            System.out.println(i);
        }
    }
}
```



# 6.4 Object Methods

所有类都继承自全局Object类。继承的方法如下：

- `String toString()`
- `boolean equals(Object obj)`
- `Class <?> getClass()`
- `int hashCode()`
- `protected Objectclone()`
- `protected void finalize()`
- `void notify()`
- `void notifyAll()`
- `void wait()`
- `void wait(long timeout)`
- `void wait(long timeout, int nanos)`

**我们将在本章中重点讨论前两个。我们将利用继承来重写类中的这两个方法**，以使它们按照我们希望的方式运行。

> `hashCode()`也很重要, 但是我们要几周后再讲它

## toString()

The `toString()` method provides a string representation of an object. **==The `System.out.println()` function implicitly calls this method on whatever object is passed to it and prints the string returned==. When you run `System.out.println(dog)`, it's actually doing this:**

```java
String s = dog.toString()
System.out.println(s)
```

**==The default `Object` class' `toString()` method prints the location of the object in memory.==** This is a hexidecimal(十六进制的) string. **Classes like Arraylist and java arrays have their own overridden versions of the `toString()` method**. This is why, when you were working with and writing tests for Arraylist, errors would always return the list in a nice format like this (1, 2, 3, 4) instead of returning the memory location.

对于我们自己编写的类，如“`ArrayDeque`”、“`LinkedListDeque`”等，如果希望能够看到以可读格式打印的对象，我们需要提供自己的“`toString()`”方法。

让我们尝试为“`ArraySet`”类编写此方法。阅读下面的“`ArraySet`”类，确保您了解各种方法的作用。请将代码插入到java可视化工具中，以获得更好的理解！

```java
import java.util.Iterator;

public class ArraySet<T> implements Iterable<T> {
    private T[] items;
    private int size; // the next item to be added will be at position size

    public ArraySet() {
        items = (T[]) new Object[100];
        size = 0;
    }

    /* Returns true if this map contains a mapping for the specified key.
     */
    public boolean contains(T x) {
        for (int i = 0; i < size; i += 1) {
            if (items[i].equals(x)) {
                return true;
            }
        }
        return false;
    }

    /* Associates the specified value with the specified key in this map.
       Throws an IllegalArgumentException if the key is null. */
    public void add(T x) {
        if (x == null) {
            throw new IllegalArgumentException("can't add null");
        }
        if (contains(x)) {
            return;
        }
        items[size] = x;
        size += 1;
    }

    /* Returns the number of key-value mappings in this map. */
    public int size() {
        return size;
    }

    /** returns an iterator (a.k.a. seer) into ME */
    public Iterator<T> iterator() {
        return new ArraySetIterator();
    }

    private class ArraySetIterator implements Iterator<T> {
        private int wizPos;

        public ArraySetIterator() {
            wizPos = 0;
        }

        public boolean hasNext() {
            return wizPos < size;
        }

        public T next() {
            T returnItem = items[wizPos];
            wizPos += 1;
            return returnItem;
        }
    }

    @Override
    public String toString() {
        /* hmmm */
    }


    @Override
    public boolean equals(Object other) {
        /* hmmm */
    }

    public static void main(String[] args) {
        ArraySet<Integer> aset = new ArraySet<>();
        aset.add(5);
        aset.add(23);
        aset.add(42);

        //iteration
        for (int i : aset) {
            System.out.println(i);
        }

        //toString
        System.out.println(aset);

        //equals
        ArraySet<Integer> aset2 = new ArraySet<>();
        aset2.add(5);
        aset2.add(23);
        aset2.add(42);

        System.out.println(aset.equals(aset2));
        System.out.println(aset.equals(null));
        System.out.println(aset.equals("fish"));
        System.out.println(aset.equals(aset));
}
```

You can find the [solutions here (ArraySet.java)](https://github.com/Berkeley-CS61B/lectureCode-sp19/blob/af2325c600010a8894a6ce3a3ccf517547145ec1/inheritance4/ArraySet.java)

**Exercise 6.4.1:** Write the toString() method so that when we print an ArraySet, it prints the elements separated by commas inside of curly braces. i.e {1, 2, 3, 4}. Remember, the toString() method should return a string.

**Solution**

```java
public String toString() {
    String returnString = "{";
    for (int i = 0; i < size; i += 1) {
        returnString += keys[i];
        returnString += ", ";
    }
    returnString += "}";
    return returnString;
}
```

==**This solution, although seemingly simple and elegant, is actually very naive.**== This is because when you use string concatenation in Java like so: `returnString += keys[i];` ==**you are actually not just appending to `returnString`, you are creating an entirely new string.**== This is incredibly inefficient because creating a new string object takes time too! Specifically, linear in the length of the string.

**Bonus Question:** 假设将一个字符连接到一个字符串需要1秒钟。如果我们有一个大小为5的ArraySet：“`｛1，2，3，4，5｝`”，那么运行“`toString()`”方法需要多长时间？

**Answer:** We set `returnString` to the left bracket which takes one second because this involves adding `{` to the empty string `""`. Adding the first element will involve creating an entirely new string, adding } and 1 which would take 2 seconds. Adding the second element takes 3 seconds because we need to add `{`, `1`, `2`. This process continues, so for the entire array set the total time is `1 + 2 + 3 + 4 + 5 + 6 + 7.`

To remedy this, Java has a special class called `StringBuilder`. It creates a string object that is mutable, so you can continue appending to the same string object instead of creating a new one each time**.==为了解决这个问题，Java有一个名为“`StringBuilder`”的特殊类。它创建了一个可变的字符串对象，因此您可以继续追加到同一个字符串对象，而不是每次都创建一个新的字符串对象。==**

**Exercise 6.4.2:** Rewrite the toString() method using StringBuilder.

**Solution**

```java
public String toString() {
        StringBuilder returnSB = new StringBuilder("{");
        for (int i = 0; i < size - 1; i += 1) {
            returnSB.append(items[i].toString());
            returnSB.append(", ");
        }
        returnSB.append(items[size - 1]);
        returnSB.append("}");
        return returnSB.toString();
    }
```

Now you've successfully overridden the `toString()` method! Try printing the ArraySet to see the fruits of your work.

Next we will override another important object method: `equals()`

## equals()

`equals()` and `==` have different behaviors in Java. `==` Checks if two objects are actually the same object in memory. Remember, pass-by-value! `==` checks if two boxes hold the same thing. For primitives, this means checking if the values are equal. For objects, this means checking if the address/pointer is equal.==**`equals()`和`==`在Java中有不同的行为。`==`检查两个对象是否实际上是内存中的同一对象**==。记住，按值传递！==**`==`检查两个盒子是否装着相同的东西**==。==对于基元，**这意味着检查值是否相等。对于对象，这意味着检查地址/指针是否相等。**==

Say we have this `Doge` class:

```java
public class Doge {

   public int age;
   public String name;

   public Doge(int age, String name){
      this.age = age;
      this.name = name;
   }
   public static void main(String[] args) {

      int x = 5;
      int y = 5;
      int z = 6;

      Doge fido = new Doge(5, "Fido");
      Doge doggo = new Doge(6, "Doggo");
      Doge fidoTwin = new Doge(5, "Fido");
      Doge fidoRealTwin = fido;
   }
}
```

如果我们将此代码插入到java可视化工具中，我们将看到下面所示的指针图中的方框。

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Doge.png)

Exercise 6.4.2: What would java return if we ran the following?

- `x == y`
- `x == z`
- `fido == doggo`
- `fido == fidoTwin`
- `fido = fidoRealTwin`

**Answers**

- `True`
- `False`
- `False`
- `False`
- `True`

`fido` and `fidoTwin` are not considered `==` because they point to different objects. However, this is quite silly since all their attributes are the same. You can see how `==` can cause some problems in Java testing. When we write tests for our ArrayList and want to check if expected is the same as what is returned by our function, we create expected as a new arraylist. If we used `==` in our test, it would always return false. This is what `equals(Object o)` is for.

### `equals(Object o)`

**`equals(Object o)`是Object中的一个方法，默认情况下，它的作用类似于==，因为它检查this的内存地址是否和o相同。然而，我们可以重写它，以任意方式定义equals！例如，要使两个Arraylist被视为相等，它们只需要具有相同顺序的相同元素。**

**Exercise 6.4.3:** 让我们为ArraySet类编写一个equals方法。记住，集合是唯一元素的无序集合。所以，要想两个集合被视为相等，你只需要检查它们是否具有相同的元素。

**Solution**

```java
public boolean equals(Object other) {
        if (this == other) { //直接都是一个内存盒了(地址都一样了,肯定是true)
            return true;
        }
        if (other == null) {
            return false;
        }
        if (other.getClass() != this.getClass()) {
            return false;
        }
        ArraySet<T> o = (ArraySet<T>) other;
        if (o.size() != this.size()) {
            return false;
        }
        for (T item : this) {
            if (!o.contains(item)) {
                return false;
            }
        }
        return true;
    }
```

让我们为ArraySet类编写一个equals方法。记住，集合是唯一元素的无序集合。所以，要想两个集合被视为相等，你只需要检查它们是否具有相同的元素。.

**Rules for Equals in Java:** When overriding a `.equals()` method, it may sometimes be trickier than it seems. A couple of rules to adhere to while implementing your `.equals()` method are as follows:当重写`.equals()`方法时，有时可能比看起来更复杂。在实现“`.equals（）`”方法时要遵守的几个规则如下：

1.) ==`equals` must be an equivalence relation==

- **reflexive**: `x.equals(x)` is true**反身**：“`x.equals(x)`”为真
- **symmetric**: `x.equals(y)` if and only if `y.equals(x)` **对称**：`x.equals（y）`当且仅当`y.equals（x）`
- **transitive**: `x.equals(y)` and `y.equals(z)` implies `x.equals(z)` **传递**：`x.equals(y)`和`y.equals(z)`表示“x.equal(z)`

2.) It must take an Object argument, in order to override the original==`.equals()` method它必须采用Object参数==，以便覆盖原始的“.equals（）”方法

3.) It must be consistent if `x.equals(y)`, then as long as `x` and `y` remain unchanged: `x` must continue to equal `y`如果“x.equals（y）”，则只要“x”和“y”保持不变，则必须一致：“x”必须继续等于“y”`

4.) It is never true for null `x.equals(null)` must be false **对于null“x.equals（null）”必须为false，它永远不为真**

### Bonus video

Create an even better `toString` method and `ArraySet.of`:

> `jion` 和 `of`

> 先略过, 以后有机会再学