# Encapsulation, API's. ADT's

### Efficient Programming

“An engineer will do for a dime what any fool will do for a dollar” -- Paul Hilfinger“ 一个工程师一毛钱就能做任何傻瓜一美元就能做的事”——保罗·希尔芬格

Efficiency comes in two flavors(风格，特色):

**1.) ==Programming cost.==**

- **How long does it take to develop your programs?**
- **How easy is it to read, modify, and maintain your code?**

**2.) ==Execution cost==(starting next week).**

- **How much time does your program take to execute?**
- **How much memory does your program require?**

*Today, we will be focusing on how to reduce programming cost.* Of course, want to keep programming costs low, both so we can write code faster and so we can have less frustrated people which will also help us write code faster (people don't code very fast when they are frustrated). 今天，我们将关注如何降低编程成本。当然，我们希望保持编程成本低，这样既可以更快地编写代码，也可以减少沮丧的人，这也有助于我们更快地写代码（人们在沮丧时不会很快地编写代码）。

Some helpful Java features discussed in 61B:

- **Packages.**
  - Good: Organizing, making things package private
  - Bad: Specific
- **Static type checking.**
  - Good: Checks for errors early , reads more like a story
  - Bad: Not too flexible, (casting)
- **Inheritance.**
  - Good: Reuse of code
  - Bad: “Is a”, **the path of debugging gets annoying**, can’t instantiate, implement every method of an interface

We will explore some new ways in this chapter!我们将在本章中探索一些新的方法！

## Encapsulation 封装

We will first define a few terms: 我们将首先定义几个术语：

- ==**Module(模块):** A set of methods that work together as a whole to perform some task or set of related tasks.==
- ==**Encapsulated:** A module is said to be encapsulated **if its implementation is completely hidden, and it can be accessed only through a documented interface.**==

## API's

**An API(Application Programming Interface) of an ADT is the list of constructors and methods and a short description of each.**

API consists of syntactic(语法的) and semantic(语义的) specification.

- **Compiler verifies that syntax is met. 编译器验证是否符合语法**
  - AKA(又称作), **everything specified in the API is present. API中指定的所有内容都存在.**
- **Tests help verify that semantics are correct.**
  - AKA **everything actually works the way it should.**
  - Semantic specification usually written out in English (possibly including usage examples). Mathematically precise formal specifications are somewhat possible but not widespread.

## ADT's

==ADT's (Abstract Data Structures) are high-level types that are defined by their **behaviors**, not their implementations.==

> **i.e.) Deque in Proj1 was an ADT that had certain behaviors (addFirst, addLast, etc.). But, the data structures we actually used to implement it was ArrayDeque and LinkedListDeque**

Some ADT's are actually special cases of other ADT's. For example, Stacks and Queues are just lists that have even more specific behavior. ==**有些ADT实际上是其他ADT的特例**==。例如，堆栈和队列只是具有更具体行为的列表。

**Exercise 8.1.1**
Write a Stack class using a Linked List as its underlying data structure. You only need to implement a single function: push(Item x). Make sure to make the class generic with "Item" being the generic type!使用linked list作为其基础数据结构编写Stack类。您只需要实现一个函数：push（项x）。确保类是泛型的，“Item”是泛型类型！

你可能用几种不同的方式写了它。让我们看看三种流行的解决方案：

```java
public class ExtensionStack<Item> extends LinkedList<Item> {
    public void push(Item x) {
        add(x);
    }
}
```

**==This solution uses *extension*==. it simply borrow the methods from `LinkedList<Item>` and uses them as its own.**

```java
public class DelegationStack<Item> {
    private LinkedList<Item> L = new LinkedList<Item>();
    public void push(Item x) {
        L.add(x);
    }
}
```

==**This approach uses Delegation(委派)**==. **It creates a Linked List object and calls its methods to accomplish its goal.**

```java
public class StackAdapter<Item> {
    private List L;
    public StackAdapter(List<Item> worker) {
        L = worker;
    }

    public void push(Item x) {
        L.add(x);
    }
}
```

This approach is similar to the previous one, except it can use any class that implements the **List** interface (Linked List, ArrayList, etc). 这种方法与前一种(第二种)类似，只是它可以使用实现**List**接口的任何类（LinkedList、ArrayList等）。

==**Warning**: be mindful of the difference between **"is-a" and "has-a"** relationships.==

- A cat has-a claw
- A cat is-a feline

==Earlier in the section define that delegation is accomplished by passing in a class while extension is defined as inheriting (just because it may be hard to notice at first glance)==.  本节前面的定义是，委托是通过传入类来完成的，而扩展是定义为继承的（因为乍一看可能很难注意到）。

==**Delegation vs Extension:**== Right now it may seem that Delegation and Extension are pretty much interchangeable; however, there are some important differences that must be remembered when using them.现在看来，授权和扩展似乎可以互换；然而，**在使用它们时，必须记住一些重要的区别。**

==**Extension tends to be used when you know what is going on in the parent class. In other words, you know how the methods are implemented**==. Additionally, **with extension, you are basically saying that the class you are extending from acts similarly to the one that is doing the extending.** On the other hand, Delegation is when you do not want to consider your current class to be a version of the class that you are pulling the method from. **当您知道父类中发生了什么时，通常会使用扩展。换句话说，您知道这些方法是如何实现的**。此外，**对于扩展，您基本上是说您要扩展的类的行为与正在进行扩展的类类似。另一方面，委派是指您不想将当前类视为从中提取方法的类的版本。**

Views: Views are an alternative representation of an existed object. Views essentially limit the access that the user has to the underlying object. However, changes done through the views will affect the actual object. 视图：视图是现有对象的替代表示。视图本质上限制了用户对底层对象的访问。但是，通过视图所做的更改将影响实际对象。

```java
/** Create an ArrayList. */
List<String> L = new ArrayList<>();
/** Add some items. */
L.add(“at”); L.add(“ax”); …
```

Say you only want a list from index 1 and 4. Then you can use a method called sublist do this by the following and you will 假设您只需要索引1和4中的列表。然后您可以使用一个名为sublist的方法。通过以下操作，您将

```java
/** subList me up fam. */
List<String> SL = l.subList(1, 4);
/** Mutate that thing. */
SL.set(0, “jug”);
```

Now why is this useful? Well say we want to reverse only part of the list. For example in the below image, we would want to reverse ax ban bat in the above picture.为什么这有用？好吧，我们只想反转列表的一部分。例如，在下图中，我们希望反转上图中的ax ban bat。

![reverse](https://joshhug.gitbooks.io/hug61b/content/assets/reverse_list1.png)

The most intuitive way is to create a method that takes in a list object and the indices which should be reversed. However, this can be a bit painful because we add some extraneous logic.最直观的方法是创建一个方法，该方法接受一个列表对象和应该反转的索引。然而，这可能有点痛苦，因为我们添加了一些无关的逻辑。

To get around doing this, we can just create a general reverse function that takes in a list and reverses that list. Because views mutates the underlying object that it represents, we can create a sublist like earlier and reverse the sublist. The end result would actually mutate the actual list and not the copy.为了避免这样做，我们可以创建一个通用的反转函数，它接受一个列表并反转该列表。因为视图改变了它所代表的底层对象，所以我们可以像前面一样创建一个子列表并反转子列表。最终结果实际上会改变实际列表，而不是副本。
![img](https://joshhug.gitbooks.io/hug61b/content/assets/reverse_list2.png)

This is all fine and dandy. However, it lends itself to an issue. You are claiming that you can give a list object that when manipulated, can affect the original list object- that’s a bit weird. Just thinking “How do you return an actual List but still have it affect another List?” is a bit confusing. Well the answer is access methods.为了避免这样做，我们可以创建一个通用的反转函数，它接受一个列表并反转该列表。因为视图改变了它所代表的底层对象，所以我们可以像前面一样创建一个子列表并反转子列表。最终结果实际上会改变实际列表，而不是副本。

The first thing to notice is that the sublist method returns a list type. Additionally, there is a defined class called Sublist which extends AbstractList. Since Abstract List it implements the List interface it and Sublist are List types.首先要注意的是，sublist方法返回一个列表类型。此外，还有一个名为Sublist的定义类，它扩展了AbstractList。由于Abstract List实现了List接口，所以它和Sublist是List类型。

```java
List<Item> sublist(int start, int end){
    Return new this.Sublist(start,end);
}
```

This first thing to notice from the above code is that subList returns a List type.从上面的代码中首先要注意的是，subList返回List类型。

```java
Private class Sublist extends AbstractList<Item>{
    Private int start end;
    Sublist(inst start, int end){...}
}
```

Now the reason the sublist function returns a List is because the class SubList extends AbstractList. Since AbstractList implements the List interface both it and Sublist are List Types.现在，子列表函数返回List的原因是因为sublist类扩展了AbstractList。由于AbstractList实现了List接口，因此它和Sublist都是列表类型。

```java
public Item get(int k){return AbstractList.this.get(start+k);}
public void add(int l, Item x){AbstractList.this.add(start+k, x); end+=1}
```

An observation that should be made is that getting the kth item from our sublist is the same as getting the the kth item from our original list with an offset equal to our start index. Because we are using a get method of our outer class (the most parent one) we change our original list.需要注意的是，从子列表中获取第k项与从原始列表中获取偏移量等于起始索引的第k项相同。因为我们正在使用外部类（最父类）的get方法，所以我们更改了原始列表。

Similarly, adding an element to our sublist is the same as adding an element to our original list with an offset equal to the start index of the sublist.类似地，向子列表中添加元素与向原始列表中添加偏移量等于子列表起始索引的元素相同。

**The Takeaway:**

- APIs are pretty hard to design; however, having a coherent design philosophy can make your code much cleaner and easier to deal with**.API很难设计；然而，拥有一个连贯的设计理念可以使代码更清晰、更容易处理。**
- Inheritance is tempting to use frequently, but it has problems and should be use sparingly, only when you are certain about attributes of your classes (both those being extended and doing the extending).**==继承很容易被频繁使用，但它有问题，应该谨慎使用，只有当您确定类的属性（包括正在扩展的属性和正在进行扩展的属性）时。==**



# Asymptotics I 渐进级数/渐进理论

## Asymptotics I: An Introduction to Asymptotic Analysis

We can consider the process of writing efficient programs from two different perspectives:

1. Programming Cost

    

   (everything in the course up to this date)

   1. How long does it take for you to develop your programs?
   2. How easy is it to read or modify your code?
   3. How maintainable is your code? (very important — much of the cost comes from maintenance and scalability, not development!)

2. Execution Cost

    

   (everything in the course from this point on)

   1. **Time complexity**: How much time does it take for your program to execute?
   2. **Space complexity**: How much memory does your program require?

### Example of Algorithm Cost

Objective: Determine if a *sorted* array contains any duplicates.

**Silly Algorithm**: Consider ***every*** pair, returning true if any match!

**Better Algorithm:** Take advantage of the ***sorted*** nature of our array.

- We know that if there are duplicates, they must be next to each other.
- Compare neighbors: return true first time you see a match! If no more items, return false.

We can see that the Silly algorithm seems like it’s doing a lot more unnecessary, redundant work than the Better algorithm. But how much more work? How do we actually quantify or determine how efficient a program is? This chapter will provide you the formal techniques and tools to compare the efficiency of various algorithms!

### Runtime Characterization

To investigate these techniques, we will be characterizing the runtimes of the following two functions, dup1 and dup2. These are the two different ways of finding duplicates we discussed above.

Things to keep in mind about our characterizations:

- They should be simple and mathematically rigorous.
- They should also clearly demonstrate the superiority of dup2 over dup1.

```java
//Silly Duplicate: compare everything
public static boolean dup1(int[] A) {  
  for (int i = 0; i < A.length; i += 1) {
    for (int j = i + 1; j < A.length; j += 1) {
      if (A[i] == A[j]) {
         return true;
      }
    }
  }
  return false;
}

//Better Duplicate: compare only neighbors
public static boolean dup2(int[] A) {
  for (int i = 0; i < A.length - 1; i += 1) {
    if (A[i] == A[i + 1]) { 
      return true; 
    }
  }
  return false;
}
```

### Techniques for Measuring Computational Cost

**Technique 1**: Measure execution time in seconds using a client program (i.e. actually seeing how quick our program runs in physical seconds)

*Procedure*

- Use a physical stopwatch
- Or, Unix has a built in `time` command that measures execution time.
- Or, Princeton Standard library has a `stopwatch` class

*Observations*

- As our input size increases, we can see that `dup1` takes a longer time to complete, whereas `dup2` completes at relatively around the same rate.

*Pros vs. Cons*

- Pros: Very easy to measure (just run a stopwatch). Meaning is clear (look at the actual length of time it takes to complete).
- Cons: May take a lot of time to test. Results may also differ based on what kind of machine, compiler, input data, etc. you’re running your program with.

So how does this method match our goals? It's simple, so that's good, but not mathematically rigorous. Moreover, the differences based on machine, compiler, input, etc. mean that the results may not clearly demonstrate the relationship between dup1 and dup2.

How about another method?

#### Technique 2

**Technique 2A**: Count possible operations for an array of size N = 10,000.

```java
for (int i = 0; i < A.length; i += 1) {
  for (int j = i+1; j < A.length; j += 1) {
    if (A[i] == A[j]) {
       return true;
    }
  }
}
return false;
```

*Procedure*

- Look at your code and the various operations that it uses (i.e. assignments, incrementations, etc.)
- Count the number of times each operation is performed.

*Observations*

- Some counts get tricky to count.
- How did we get some of these numbers? It can be complicated and tedious.

*Pros vs. Cons*

- Pros: Machine independent (for the most part). Input dependence captured in model.
- Cons: Tedious to compute. Array size was arbitrary (we counted for N = 10,000 — but what about for larger N? For a smaller N? How many counts for those?). Number of operations doesn’t tell you the actual time it takes for a certain operation to execute (some might be quicker to execute than others).

So maybe this one has solved some of our cons from the timing simulation above, but it has problems of its own.

**Technique 2B**: Count possible operations in terms of input array size N (symbolic counts)

*Pros vs. Cons*

- Pros: Still machine independent (just counting the number of operations still). Input dependence still captured in model. But now, it tells us how our algorithm scales as a function of the size of our input.
- Cons: Even more tedious to compute. Still doesn’t tell us the actual time it takes!

------

**Checkpoint:** Applying techniques 2A and B to `dup2`

- Come up with counts for each operation, for the following code, with respect to N.
- Predict the ***rough*** magnitudes of each one!

```java
for (int i = 0; i < A.length - 1; i += 1){
  if (A[i] == A[i + 1]) { 
    return true; 
  }
}
return false;
```