# 5.1 Autoboxing 自动装箱机制

## Industrial Strength Syntax 工业强度的语法(用于工业级实现)

在本书的前几部分中，我们讨论了各种数据结构以及Java支持其实现的方式。在本章中，我们将讨论Java程序的**工业级实现中使用的各种补充主题**。

这并不是一本全面的Java指南，而是在学习本课程时可能对您有用的一些特性的重点。

## Automatic Conversions 自动转换

### Autoboxing and Unboxing 自动装箱与拆箱

As we saw in the previous chapter, **we can define classes which have generic type variables using the `<>` syntax**, e.g. `LinkedListDeque<Item>` and `ArrayDeque<Item>`. When we want to instantiate an object whose class uses generics, we have to substitute the generic with a concrete class, i.e. specify what type of items are going to go into that class.

Recall that Java has 8 primitive types -- all other types are reference types. **One particular feature of Java is that we cannot provide a primitive type as an actual type argument for generics, e.g. `ArrayDeque<int>` is a syntax error.** Instead, we use `ArrayDeque<Integer>`. For each primitive type, we use the corresponding reference type as shown in the table below. **==These reference types are called "wrapper classes(包装类)".==**

![wrapper classes](https://joshhug.gitbooks.io/hug61b/content/assets/wrapper_classes.png)

Naively, we'd assume that this would result in having to manually convert between primitive and reference types when using a generic data structure. For example, we might imagine having to do the following:简单地说，我们假设这将导致在使用通用数据结构时必须手动在基元类型和引用类型之间进行转换。例如，我们可以设想必须执行以下操作：

```java
public class BasicArrayList {
    public static void main(String[] args) {
      ArrayList<Integer> L = new ArrayList<Integer>();
      L.add(new Integer(5));
      L.add(new Integer(6));

      /* Use the Integer.valueOf method to convert to int */
      int first = L.get(0).valueOf();
    }
}
```

Writing code like above can be a bit annoying. Luckily, **==Java can implicitly convert between primitive and wrapper types==**, **so the code below works just fine:**

```java
public class BasicArrayList {
    public static void main(String[] args) {
      ArrayList<Integer> L = new ArrayList<Integer>();
      L.add(5);
      L.add(6);
      int first = L.get(0);
    }
}
```

**==The reason this works is that Java will automatically "box" and "unbox" values between a primitive type and its corresponding reference type.==** That is, if Java expects a wrapper type, like Integer, and you provide a primitive type, like int, it will "autobox" the integer. For example, if we have the function:

```java
public static void blah(Integer x) {
    System.out.println(x);
}
```

And we call it using:

```java
int x = 20;
blah(x);
```

**Then Java ==implicitly(隐式的)== creates a new `Integer` with value 20,** resulting in a call to equivalent to calling `blah(new Integer(20))`. This process is known as autoboxing.

Likewise, if Java expected a primitive:

```java
public static void blahPrimitive(int x) {
    System.out.println(x);
}
```

but you give it a value of the corresponding wrapper type:

```java
Integer x = new Integer(20);
blahPrimitive(x);
```

It will automatically unbox the integer, equivalent to calling the `Integer` class's `valueOf` method.

> 即, ==既可以从`wrapped type`转化到`primitive`,也可以反过来==
>
> 即, ==既可以autoboxing, 也可以unboxing==

#### Caveats 警告,附加说明

There are a few things to keep in mind when it comes to autoboxing and unboxing:

- ==**Arrays are never autoboxes or auto-unboxed, e.g. if you have an array of integers `int[] x`, and try to put its address into a variable of type `Integer[]`, the compiler will not allow your program to compile.**==

- ==**Autoboxing and unboxing also has a measurable performance impact. That is, code that relies on autoboxing and unboxing will be slower than code that eschews such automatic conversions.自动装箱和拆箱也会对性能产生可衡量的影响。也就是说，依赖于自动装箱和取消装箱的代码将比避免这种自动转换的代码慢。**==

- **Additionally, wrapper types use much more memory than primitive types. On most modern comptuers, not only must your code hold a 64 bit reference to the object, but every object also requires 64 bits of overhead used to store things like the dynamic type of the object.此外，包装器类型比原始类型使用更多的内存。在大多数现代编译器中，不仅代码必须包含对对象的64位引用，而且每个对象还需要64位开销来存储对象的动态类型等内容。**

  - For more on memory usage, see [this link](http://www.javamex.com/tutorials/memory/object_memory_usage.shtml) or [this link](http://blog.kiyanpro.com/2016/10/07/system_design/memory-usage-estimation-in-java/).

  <img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230127145112828.png" alt="image-20230127145112828" style="zoom: 33%;" />

### Widening (类型)扩展

Similar to the autoboxing/unboxing process, ==**Java will also automatically widen a primitive if needed**==. Specifically, if a program expects a primitive of type T2 and is given a variable of type T1, and type T2 can take on a wider range of values than T1, the the variable will be implicitly cast to type T2. 与自动装箱/拆箱过程类似，如果需要，Java还会自动加宽原语。具体地说，如果一个程序期望一个类型为T2的原语，并且给定了一个类型T1的变量，并且类型T2可以采用比T1更宽的值范围，那么该变量将隐式转换为类型T2。

For example, **doubles in Java are wider than ints**. If we have the function shown below:

```java
public static void blahDouble(double x) {
    System.out.println(“double: “ + x);
}
```

We can call it with an int argument:

```java
int x = 20;
blahDouble(x);
```

**The effect is the same as if we'd done `blahDouble((double) x)`. Thanks Java!**

If you want to go from a wider type to a narrower type, you must manually cast. For example, if you have the method below:

```java
public static void blahInt(int x) {
    System.out.println(“int: “ + x);
}
```

Then we'd need to **use a cast** if we want to call this method using a double value, e.g.

```java
double x = 20;
blahInt((int) x);
```

For more details on widening, including a full description of what types are wider than others, see [the official Java](http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html) documentation.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230127144705112.png" alt="image-20230127144705112" style="zoom:50%;" />

# 5.2 Immutability (不变性, 主要讲final)

The notion of immutability is one of the things you might never have known existed, but that can greatly simplify your life once you realize it's a thing (sort of like the realization you get as an adult that nobody *really* knows what they're doing, at least when they first start doing something new).不变性的概念是你可能永远不知道存在的东西之一，但一旦你意识到这是一件事，它会大大简化你的生活（有点像你成年后意识到没有人真正知道自己在做什么，至少当他们开始做新的事情时）。

**==An immutable data type is a data type whose instances cannot change in any observable way after instantiation.不可变数据类型是一种数据类型，其实例在实例化后不能以任何可观察的方式更改==**。

**==For example, `String` objects in Java are immutable==**. No matter what, if you have an instance of `String`, you can call any method on that `String`, but it will remain completely unchanged. This means that when `String` objects are concatenated, neither of the original Strings are modified -- instead, a totally new `String` object is returned.这意味着当“字符串”对象被连接时，原始的字符串都不会被修改，而是返回一个全新的“字符串”。

Mutable datatypes include objects like `ArrayDeque` and `Planet`. We can add or remove items from an `ArrayDeque`, which are observable changes. Similarly, the velocity and position of a `Planet` may change over time.

Any data type with non-private variables is mutable, unless those variables are declared `final` (this is not the only condition for mutability -- there are many other ways of defining a data type so that it is mutable). This is because an outside method can change the value of non-private variables, leading to observable change. **==任何具有非私有变量的数据类型都是可变的，除非这些变量被声明为“`final`”(这不是可变的唯一条件——有许多其他方法可以定义数据类型，使其可变)==**。**这是因为外部方法可以改变非私有变量的值，从而导致==可观察到的变化==。**

The `final` keyword is a keyword for variables that prevents the variable from being changed after its first assignment. For example, consider the `Date` class below:	“`final`”关键字是变量的关键字，用于防止变量在第一次赋值后被更改。例如，考虑下面的“`Date`”类：

```java
public class Date {
    public final int month;
    public final int day;
    public final int year;
    private boolean contrived = true;
    public Date(int m, int d, int y) {
        month = m; day = d; year = y;
    }
}
```

**This class is immutable. After instantiating a `Date`, there is no way to change the value of any of its properties.**

Advantages of immutable data types:

- Prevents bugs and makes debugging easier because properties cannot change ever 防止错误并使调试更容易，因为属性永远不会更改
- You can count on objects to have a certain behavior/trait 你可以指望对象具有某种行为/特征

Disadvantages:

- **You need to create a new object in order to change a property 您需要创建新对象才能更改属性**

Caveats:

- ==**Declaring a reference as final does not make the object that reference is pointing to immutable! For example, consider the following code snippet: 将引用声明为final不会使引用指向的对象不可变！**==例如，考虑以下代码段：

  ```java
  public final ArrayDeque<String>() deque = new ArrayDeque<String>();
  ```

  The `deque` variable is final and can never be reassigned, but the array deque object its pointing to can change! ArrayDeques are always mutable!“==`deque`”变量是最终变量，永远不能重新赋值，但它指向的数组deque对象可以更改！ArrayDeques总是可变的！==

- Using the Reflection API, it is possible to make changes even to private variables! Our notion of immutability assumes that we're not using any of the special capabilities of this library. 使用反射API，甚至可以对私有变量进行更改！我们的不变性概念假设我们没有使用这个库的任何特殊功能。



# 5.3 Generics 泛型

## Creating Another Generic Class

Now that we've created generic lists, such as `DLLists` and `ALists`, **lets move on to a different data type: maps.** Maps let **you associate keys with values,** for example, the statement "Josh's score on the exam is 0" could be stored in a Map that associates students to their exam scores. ==**A map is the Java equivalent of a Python dictionary**==.

We're going to be creating the `ArrayMap` class, which implements the `Map61B` Interface, a restricted version of Java's built-in `Map` interface. `ArrayMap` will have the following methods:

```java
 put(key, value): Associate key with value.
 containsKey(key): Checks if map contains the key.
 get(key): Returns value, assuming key exists.
 keys(): Returns a list of all keys.
 size(): Returns number of keys.
```

For this exercise, we will ignore resizing. One thing to note about the `Map61B` interface (and the Java `Map` interface in general) **is that ==each key can only have one value at a time.==** If Josh is mapped to 0, and then we say "Oh wait, there was a mistake! Josh actually got 100 on the exam," we erase the value 0 that's Josh maps to and replace it with 100.

可以尝试自己构建一个“`ArrayMap`”，但完整的实现如下所示，仅供参考。

```java
package Map61B;

import java.util.List;
import java.util.ArrayList;

/***
 * An array-based implementation of Map61B.
 ***/
public class ArrayMap<K, V> implements Map61B<K, V> {

    private K[] keys;
    private V[] values;
    int size;

    public ArrayMap() {
        keys = (K[]) new Object[100]; //这会引起警报, 但是我们无法修复, 这是Java的一个"怪癖"
        values = (V[]) new Object[100];
        size = 0;
    }

    /**
    * Returns the index of the key, if it exists. Otherwise returns -1.
    **/
    private int keyIndex(K key) {
        for (int i = 0; i < size; i++) {
            if (keys[i].equals(key)) {
                // 不要用`==`, 因为`==`是比较两个对象是不是同一个对象(换句话说, 是不是同一个内存框的两个名字)
                // 而equals是比较内容是不是相同(即使是两个对象, 只要内容相同就可以)
            return i;
        }
        return -1;
    }

    public boolean containsKey(K key) {
        int index = keyIndex(key);
        return index > -1; // 常见的作法, 学会了以后很酷
    }

    public void put(K key, V value) {
        int index = keyIndex(key);
        if (index == -1) {
            keys[size] = key;
            values[size] = value;
            size += 1;
        } else {
            values[index] = value;
        }
    }

    public V get(K key) {
        int index = keyIndex(key);
        return values[index];
    }

    public int size() {
        return size;
    }

    public List<K> keys() {
        List<K> keyList = new ArrayList<>();
        for (int i = 0; i < keys.length; i++) {
            keyList.add(keys[i]);
        }
        return keyList;
    }
}
```

Note: the decision to name the generics `K` and `V` is arbitrary (but meant to be intuitive). We could have just as well replaced these generics with `Potato` and `Sauce`, or any other name. **However, it's quite common to see generics in Java represented as a single uppercase letter, in this course and elsewhere.**

There were a few interesting things here; looking at the top of the code, we stated `package Map61B;`. We will go over this a bit later, but for now just know that it means we are putting our `ArrayMap` class within a folder called Map61B. Additionally, we import `List` and `ArrayList` from `java.utils`. 这里有一些有趣的事情；在代码的顶部，我们声明了“`package Map61B;`”。稍后我们将讨论这个问题，但现在只知道这意味着我们将“`ArrayMap`”类放在一个名为`Map61B`的文件夹中。此外，我们还从“`java.utils`”导入“`List`”和“`ArrayList`”。

**Exercise 5.2.1:** In our current implementation of ArrayMap, there is a bug. Can you figure out what it is?

**Answer:** In the `keys` method, the for loop should be iterating until `i == size`, not `keys.length`.

## ArrayMap and Autoboxing Puzzle

如果我们编写如下所示的测试：

```java
@Test
public void test() { 
    ArrayMap<Integer, Integer> am = new ArrayMap<Integer, Integer>();
    am.put(2, 5);
    int expected = 5;
    assertEquals(expected, am.get(2));
}
```

You will find that we get a compile-time error!

```bash
$ javac ArrayMapTest.java
ArrayMapTest.java:11: error: reference to assertEquals is ambiguous
    assertEquals(expected, am.get(2));
    ^
    both method assertEquals(long, long) in Assert and method assertEquals(Object, Object) in Assert match
```

**We get this error because JUnit's `assertEquals` method is overloaded, eg. `assertEquals(int expected, int actual)`, `assertEquals(Object expected, Object actual)`, etc. Thus, Java is unsure which method to call for `assertEquals(expected, am.get(2))`, ==which requires one argument to be autoboxed/unboxed==.**

**Excercise 5.2.2** What would we need to do in order to call `assertEquals(long, long)`?

 **A.) Widen `expected` to a `long`** 

 B.) Autobox `expected` to a `Long` 

 **C.) Unbox `am.get(2)`** 

 **D.) Widen the unboxed `am.get(2)` to long**

**Answer** A, C, and D all work.

**Excercise 5.2.3** ==How would we make it work with `assertEquals(Object, Object)`?==

**Answer** ==Autobox `expected` to an `Integer` because `Integers` are `Objects`.==

**Excercise 5.2.4** How do we make the code compile with casting?

**Answer** Cast `expected` to `Integer`.

## Generic Methods 泛型方法 

The goal for the next section is to create a class `MapHelper` which will have two methods:

- ```
  get(Map61B, key)
  ```

  : Returns the value corresponding to the given key in the map if it exists, otherwise null.

  - This is useful because `ArrayMap` currently has a bug where the get method throws an ArrayIndexOutOfBoundsException if we try to get a key that doesn't exist in the `ArrayMap`.

- `maxKey(Map61B)`: Returns the maximum of all keys in the given `ArrayMap`. Works only if keys can be compared.

### Implementing get

`get` is a static method that takes in a Map61B instance and a key and returns the value that corresponds to the key if it exists, otherwise returns null.

**Excercise 5.2.5** Try writing this method yourself!

As you see in the video, we could write a very limited method by declare the parameters as String and Integer like so:

```java
public static Integer get(Map61B<String, Integer> map, String key) {
    ...
}
```

We are restricting this method to only take in `Map61B<String, Integer>`, which is not what we want! We want it to take any kind of `Map61B`, no matter what the actual types for the generics are. However, the following method header produces a compilation error:

```java
public static V get(Map61B<K, V> map, String key) {
    ...
}
```

This is because with generics defined in class headers, Java waits for the user to instantiate an object of the class in order to know what actual types each generic will be. However, here we'd like a generic specific to this method. Moreover, we do not care what actual types `K` and `V` take on in our `Map61B` argument -- the important part is that whatever `V` is, an object of type `V` is returned.

Thus we see the need for **==generic methods(此例中不要将类变成泛型, 因为没人会初始化这个类, 我们需要"*方法泛型*")==**. To declare a method as generic, the formal type parameters must be specified before the return type:

```java
public static <K,V> V get(Map61B<K,V> map, K key) {
    if map.containsKey(key) {
        return map.get(key);
    }
    return null;
}
```

Here's an example of how to call it:

```java
ArrayMap<Integer, String> isMap = new ArrayMap<Integer, String>();
System.out.println(mapHelper.get(isMap, 5));
```

You don't need any explicit declaration of what type you are inserting. Java can infer that isMap is an `ArrayMap` from `Integers` to `Strings`.

## Implementing maxKey

**Exercise 5.2.6** Try writing this method yourself!

Here's something that looks OK, but isn't quite correct:

```java
public static <K, V> K maxKey(Map61B<K, V> map) {
    List<K> keylist = map.keys();
    K largest = map.get(0);
    for (K k: keylist) {
        if (k > largest) {
            largest = k;
        }
    }
    return largest;
}
```

**Exercise 5.2.7** Can you spot what's wrong with this method?

**Answer:** **==The `>` operator can't be used to compare `K` objects. This only works on primitives and `map` may not hold primitives!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(`>`操作符并不能作用于非primitive类型)==**

We will rewrite this method as such:

```java
public static <K, V> K maxKey(Map61B<K, V> map) {
    List<K> keylist = map.keys();
    K largest = map.get(0);
    for (K k: keylist) {
        if (k.compareTo(largest)) {
            largest = k;
        }
    }
    return largest;
}
```

> **==改用`compareTo`==**

**Exercise 5.2.8** This is also wrong, why?

**Answer** ==**Not all objects have a `compareTo` method!**==

We will introduce a little more syntax for generic methods in the header of the function.

```java
public static <K extends Comparable<K>, V> K maxKey(Map61B<K, V> map) {...}
```

The `K extends Comparable<K>` means keys must implement the comparable interface and can be compared to other K's. We need to include the `<K>` after `Comparable` because `Comparable` itself is a generic interface! Therefore, we must specify what kind of comparable we want. In this case, we want to compare K's with K's.

## Type upper bounds

==You might be wondering, why does it "extend" comparable and not "implement"? Comparable is an interface after all.你可能会想，为什么它“扩展”了可比性而不是“实现”？毕竟，Comparable是一个接口。==

==Well, it turns out, "extends" in this context has a different meaning than in the polymorphism context. **事实证明，在这个上下文中，“extends”的含义与多态上下文中的含义不同。**==

==When we say that the Dog class extends the Animal class, we are saying that Dogs can do anything that animals can do and more! We are **giving** Dog the abilities of an animal. When we say that K extends Comparable, we are simply stating a fact. We aren't **giving** K the abilities of a Comparable, we are just saying that K **must be** Comparable. This different use of `extends` is called type upper bounding. Confusing? That's okay, it *is* confusing. Just remember, in the context of inheritance, the `extends` keyword is active in giving the subclass the abilities of the superclass. You can think of it as a fairy Godmother: she sees your needs and helps you out with some of her fairy magic. On the other hand, in the context of generics, `extends` simply states a fact: You must be a subclass of whatever you're extending. **When used with generics (like in generic method headers), `extends` imposes a constraint rather than grants new abilities.** It's akin to a fortune teller, who just tells you something without doing much about it.==

==当我们说狗类扩展了动物类时，我们是说狗可以做任何动物可以做的事情，甚至更多！我们正在给狗一种动物的能力。当我们说K扩展了Comparable时，我们只是在陈述一个事实。我们并没有**给**K一个可比的能力，我们只是说K**必须是**可比的。“extends”的这种不同用法称为类型上限。令人困惑没关系，这让人困惑。请记住，**在继承的上下文中**，“extends”关键字在赋予子类超类的能力方面是活跃的。你可以把它想象成一个仙女教母：她看到你的需求，并用她的一些魔法帮助你。另一方面，**在泛型的上下文中**，“extends”只是陈述了一个事实：您必须是所扩展对象的子类. **当与泛型一起使用时（如在泛型方法头中），“extends”施加了一个约束，而不是授予新的能力。**这类似于算命先生，他只是告诉你一些事情而没有做太多。==

> 分清 "在继承的上下文中" 和 "在泛型的上下文中"

## Summary

We’ve seen four new features of Java that make generics more powerful:

- **Autoboxing and auto-unboxing of primitive wrapper types.**
- **Promotion/widening between primitive types.**
- **Specification of generic types for methods (before return type).**
- **Type upper bounds in generic methods (e.g. `K extends Comparable<K>`).**

