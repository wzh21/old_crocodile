# 7.1 Packages

### Packages and JAR files

使用世界上的所有代码，您很可能会创建与来自不同项目的类共享名称的类。你如何组织这些类，以便在尝试访问或使用它们时减少歧义？你的程序如何知道你打算使用Dog.class，而不是Josh Hug的Dog.class？

Herein enters the ==**package** — a namespace that organizes classes and interfaces==. In general, when creating packages you should follow the following naming convention: package name starts with the website address, backwards.

For example, if Josh Hug were trying to distribute his Animal package, which contains various different types of animal classes, he would name his package as following:

```
ug.joshh.animal; // note: his website is joshh.ug
```

However, in CS61B you do not have to follow this convention(习俗,惯例), as your code isn’t intended for distribution.然而，在CS61B中，您不必遵循此约定，因为您的代码不是用于分发的。

## Using Packages

If you’re accessing the class from within the same package, you can just use its simple name:

```java
Dog d = new Dog(...);
```

If you’re accessing the classes **from outside the package**, then use its entire canonical name:

```java
ug.joshh.animal.Dog d = new ug.joshh.animal.Dog(...);
```

To make things easier, **you can import the package**, and use the simple name instead!

```java
import ug.joshh.animal.Dog;
...
Dog d = new Dog(...);
```

## Creating a Package

**Creating a package takes the following two steps:**

1.) **Put the package name at the top of every file in this package**

```java
package ug.joshh.animal;

public class Dog {
    private String name;
    private String breed;
    …
}
```

2.) **Store the file in a folder that has the appropriate folder name. The folder should have a name that matches your package:**

**i.e. `ug.joshh.animal` package is in ug/joshh/animal folder**

**Creating a Package, in IntelliJ**

1.) File → New Package

1.) Choose package name (i.e. “ug.joshh.animal”)

**Adding (new) Java Files to a Package, in IntelliJ**

1.) Right-click package name

2.) Select New → Java Class

3.) Name your class, and IntelliJ will automatically put it in the correct folder + add the “package ug.joshh.animal” declaration for you.

**Adding (old) Java Files to a Package, in IntelliJ**

1.) Add “package [packagename]” to the top of the file.

2.) Move the .java file into the corresponding folder.

> 直接拖拽即可

## Default packages

Any Java class without an explicit package name at the top of the file is automatically considered to be part of the “default” package. However, when writing real programs, you should avoid leaving your files in the default package (unless it’s a very small example program). This is because code from the default package cannot be imported, and it is possible to accidentally create classes with the same name under the default package.任何在文件顶部没有显式包名的Java类都会自动被视为“默认”包的一部分。然而，==**在编写真正的程序时，应该避免将文件留在默认包中（除非它是一个非常小的示例程序）**==。==**这是因为无法导入默认包中的代码，并且可能会在默认包下意外创建同名的类。**==

**For example, if I were to create a “DogLauncher.java” class in the default package, I would be unable to access this DogLauncher class anywhere else outside of the default package.**

```java
DogLauncher.launch(); // won’t work
default.DogLauncher.launch(); // doesn’t exist
```

**==因此，Java文件通常应该以显式的包声明开始。==**

## JAR Files

Oftentimes, programs will contain multiple .class files. If you wanted to share this program, rather than sharing all the .class files in special directories, you can “zip” all the files together by creating a JAR file. This single .jar file will contain all your .class files, along with some other additional information. **通常，程序将包含多个.class文件。如果您想共享这个程序，而不是共享特殊目录中的所有.class文件，可以通过创建JAR文件将所有文件“压缩”在一起。这个.jar文件将包含所有.class文件，以及一些其他信息。**

It is important to note that JAR files are just like zip files. It is entirely possible to unzip and transform the files back into .java files. JAR files do not keep your code safe, and thus you should not share your .jar files of your projects with other students. **需要注意的是，JAR文件就像zip文件一样。完全可以将文件解压缩并转换回.java文件。**JAR文件不能保证代码的安全，因此您不应该与其他学生共享项目的.JAR文件。

**Creating a JAR File (IntelliJ)**

1.) Go to File → Project Structure → Artifacts → JAR → “From modules with dependencies”

2.) Click OK a couple of times

3.) Click Build → Build Artifacts (this will create a JAR file in a folder called “Artifacts”)

4.) Distribute this JAR file to other Java programmers, who can now import it into IntelliJ (or otherwise)

==**Build Systems**==

Rather than importing a list of libraries or whatnot each time we wanted to create a project, we can simply put the files into the appropriate place, and use “Build Systems” to automate the process of setting up your project. The advantages of Build Systems are especially seen in bigger teams and projects, where it’s largely beneficial to automate the process of setting up the project structure. Though the advantages of Build Systems are rather minimal in 61B, we did use ==Maven== in Project 3 (BearMaps, Spring 2017), which is one of many popular build systems (including ==Ant and Gradle==).

# 7.2 Access Control

We now run into the question of how public and private members behave in packages and subclasses. Think to yourself right now: when inheriting from a parent class, can we access the private members in that parent class? Or, can two classes in the same package access the other’s private members?

If you don’t know the answers right away, you can read on to find out!

**Private** Only code from the given class can access **private** members. It is truly *private* from everything else, as subclasses, packages, and other external classes cannot access private members. *TL;DR: only the class needs this piece of code*

**Package Private** This is the default access given to Java members if there is no explicit modifier written. Package private entails that classes that belong in the same package can access, but not subclasses! Why is this useful? Usually, packages are handled and modified by the same (group of) people. It is also common for people to extend classes that they didn’t initially write. The original owners of the class that’s being extended may not want certain features or members to be tampered with, if people choose to extend it — hence, package-private allows those who are familiar with the inner workings of the program to access and modify certain members, whereas it blocks those who are subclassing from doing the same. *TL;DR: only classes that live in the same package can access*

**Protected** Protected members are protected from the “outside” world, so classes within the same package and subclasses can access these members, but the rest of the world (e.g. classes external to the package or non-subclasses) cannot! *TL;DR: subtypes might need it, but subtype clients will not*

**Public** This keyword opens up the access to everyone! This is generally what clients of the package can rely on to use, and once deployed, the public members’ signatures should not change. It’s like a promise and contract to people using this public code that it will always be accessible to them. Usually if developers want to “get rid of” something that’s public, rather than removing it, they would call it “deprecated” instead.

*TL;DR: open and promised to the world*

**Exercise 7.1.1** See if you can draw the access table yourself, from memory.

Have the following be the column titles: Modifier, Class, Package, Subclass, World, with the following as the Rows: public, protected, package-private, private.

Indicate whether or not each row/access type has access to that particular column’s “type”.

![access](https://joshhug.gitbooks.io/hug61b/content/assets/access_modifiers.png)

> 黑框表示不显式指出访问权限, 此时叫做package private

## Access Control Subtleties(微妙)

**Default Package** Code that does not have a package declaration is automatically part of the default package. If these classes have members that don’t have access modifiers (i.e. are package-private), then because everything is part of the same (unnamed) default package, these members are still accessible between these “default”-package classes.

**默认包 **没有包声明的代码自动成为默认包的一部分。如果这些类的成员没有访问修饰符（即包私有），那么因为所有内容都是同一个（未命名）默认包的一部分，所以这些成员仍然可以在这些“默认”包类之间访问。

**==Access is Based Only on Static Types!!!!!!!!!!!!!!!!==** **It is important to note that for interfaces, the default access for its methods is actually public, and not package-private. Additionally, like this subtitle indicates, the access depends only on the static types.**

**Exercise 7.1.2**

Given the following code, which lines in the demoAccess method, if any, will error during compile time?

```java
package universe;
public interface BlackHole {
    void add(Object x); // this method is public, not package-private!
}

package universe;
public class CreationUtils {
    public static BlackHole hirsute() {
         return new HasHair();
    }
}

package universe;
class HasHair implements BlackHole {
    Object[] items;
    public void add(Object o) { ... }
    public Object get(int k) { ... }
}

import static CreationUtils.hirsute;
class Client {
   void demoAccess() {
      BlackHole b = hirsute();
      b.add("horse");
      b.get(0);
      HasHair hb = (HasHair) b;
   }
}
```

**ANSWER**

- b.get(0); This line errors because `b` is of static type `BlackHole`, but the `BlackHole` interface does not define a `get` method! Even though you and I both know that `b` is dynamically a `HasHair`, and thus has the `get` method, the compiler bases its checks off the static type.
- HasHair hb = (HasHair) b; This one is tricky, but notice that the `HasHair` class is not a public class - it's package-private. This means that `Client`, a class outside of the `universe` package, can't see that the `HasHair` class exists.

> ==`import static`是**静态导入**的意思, **会导入所有的静态成员**==