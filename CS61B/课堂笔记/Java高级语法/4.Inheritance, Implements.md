# Intro and Interfaces

## The Problem

回想一下我们上周创建的两个列表类：SLList和AList。如果你看一下他们的文档，你会发现他们非常相似。事实上，他们所有的支持方法都是一样的！

假设我们要编写一个类“`WordUtils`”，其中包含可以在单词列表上运行的函数，包括计算SLList中最长字符串的方法。

**Exercise 4.1.1.** Try writing this method by yourself. The method should take in an SLList of strings and return the longest string in the list.试着自己写这个方法。该方法应接受字符串的SLList，并返回列表中最长的字符串。

Here is the method that we came up with.

```java
public static String longest(SLList<String> list) {
    int maxDex = 0;
    for (int i = 0; i < list.size(); i += 1) {
        String longestString = list.get(maxDex);
        String thisString = list.get(i);
        if (thisString.length() > longestString.length()) {
            maxDex = i;
        }
    }
    return list.get(maxDex);
}
```

我们如何使这种方法也适用于AList？

All we really have to do is change the **method's signature**: the parameter

```java
SLList<String> list
```

should be changed to

```java
AList<String> list
```

Now we have two methods in our `WordUtils` class with exactly the same method name.

```java
public static String longest(SLList<String> list)
```

and

```java
public static String longest(AList<String> list)
```

This is actually allowed in Java! It's something called ==***method overloading(方法重载)***==. When you call WordUtils.longest, Java knows which one to run according to what kind of parameter you supply it. If you supply it with an AList, it will call the AList method. Same with an SLList.

It's nice that Java is smart enough to know how to deal with two of the same methods for different types, but overloading has several downsides:Java足够聪明，知道如何处理不同类型的两个相同方法，这很好，**但重载有几个缺点**：

- 这是超级重复和丑陋的，因为你现在有两个几乎相同的代码块。
- 它需要维护更多的代码，这意味着如果你想对“最长”的方法做一些小的修改，比如纠正错误，你需要在每种类型列表的方法中进行修改。
- 如果我们想创建更多的列表类型，我们必须为每个新的列表类复制该方法。

## Hypernyms, Hyponyms, and Interface Inheritance 上下位关系和继承

在英语语言和日常生活中，单词和对象都存在逻辑层次。

Dog is what is called a *hypernym of* poodle, malamute, husky, etc. In the reverse direction, poodle, malamute, and husky, are *hyponyms* of dog.

These words form a hierarchy of "==**is-a**==" relationships:

- a poodle "is-a" dog
- a dog "is-a" canine
- a canine "is-a" carnivore
- a carnivore "is-an" animal

<img src="https://joshhug.gitbooks.io/hug61b/content/assets/hierarchy.png" alt="hierarchy" style="zoom:50%;" />



The same hierarchy goes for SLLists and ALists! SLList and AList are both hyponyms of a more general list.

We will formalize this relationship in Java: if a SLList is a hyponym of List61B, then the SLList class is a **==subclass==** of the List61B class and the List61B class is a **==superclass==** of the SLList class.

**Figure 4.1.1** ![subclass](https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png)

In Java, in order to *express* this hierarchy, we need to do **two things**:

- Step 1: Define a type for the general list hypernym -- we will choose the name List61B.
- Step 2: Specify that SLList and AList are hyponyms of that type.

==The new List61B is what Java calls an **interface(接口)**==. It is essentially a contract that specifies what a list must be able to do, but it doesn't provide any implementation for those behaviors. Can you think of why?

Here is our List61B interface. At this point, we have satisfied the first step in establishing the relationship hierarchy: creating a hypernym.

```java
public interface List61B<Item> {
    public void addFirst(Item x);
    public void add Last(Item y);
    public Item getFirst();
    public Item getLast();
    public Item removeLast();
    public Item get(int i);
    public void insert(Item x, int position);
    public int size();
}
```

> 必须是public的, private在这里是error的, 且没有任何意义

Now, to complete step 2, we need to specify that AList and SLList are hyponyms of the List61B class. In Java, we define this relationship in the class definition.

We will add to

```java
public class AList<Item> {...}
// 注意, 这里的<Item>是泛型语法的一部分, 和继承无关
```

a relationship-defining word: implements.

```java
public class AList<Item> implements List61B<Item>{...}
```

==`implements List61B<Item>` is essentially a promise. AList is saying "I promise I will have and define all the attributes and behaviors specified in the List61B interface"==

Now we can edit our `longest` method in `WordUtils` to take in a List61B. Because AList and SLList share an "is-a" relationship.

## Overriding 重写

We promised we would implement the methods specified in List61B in the AList and SLList classes, so let's go ahead and do that.

**==When implementing the required functions in the subclass, it's useful (and actually required in 61B) to include the `@Override` tag right on top of the method signature.==** Here, we have done that for just one method.

```java
@Override
public void addFirst(Item x) {
    insert(x, 0);
}
```

**It is good to note that even if you don’t include this tag, you *are* still overriding the method. So technically, you don't *have* to include it. However, including the tag acts as a safeguard for you as the programmer by alerting the compiler that you intend to override this method.** Why would this be helpful you ask? Well, it's kind of like having a proofreader(校对员)! **The compiler will tell you if something goes wrong in the process.**

假设要重写“`addLast`”方法。如果你错了字，不小心写了“`addLsat`”怎么办？==如果不包含@Override标记，则可能无法捕捉到错误，这可能会使调试变得更加困难和痛苦。而如果包含@Override，编译器将停止并提示您在程序运行之前修复错误==。

## Interface Inheritance

Interface Inheritance refers to a relationship in which a subclass inherits all the methods/behaviors of the superclass. As in the List61B class we defined in the **Hyponyms and Hypernyms** section, the interface includes all the method signatures, but not implementations. It's up to the subclass to actually provide those implementations.接口继承是指子类继承父类的所有方法/行为的关系。正如我们在**Hypoyms和Hyperyms**部分中定义的List61B类一样，==接口包括所有方法签名，但不包括实现。由子类来实际提供这些实现==。

这种继承也是多代的。这意味着，如果我们有一个很长的超类/子类关系谱系，如**图4.1.1**所示，AList不仅继承了List61B中的方法，而且还继承了它上面的所有其他类，直到最高的超类AKA AList继承自Collection。

# GRoE 黄金等号法则

Recall the Golden Rule of Equals we introduced in the first chapter. **This means whenever we make an assignment `a = b` , we copy the bits from b into a, with the ==requirement that b is the same type as a==.** You can't assign `Dog b = 1` or `Dog b = new Cat()` because 1 is not a Dog and neither is Cat.

Let's try to apply this rule to the `longest` method we wrote previously in this chapter.

`public static String longest(List61B<String> list)` takes in a List61B. We said that this could take in AList and SLList as well, but how is that possible since AList and List61B are different classes? Well, recall that AList shares an "is-a" relationship with List61B, Which means an AList should be able to fit into a List61B box!

**Exercise 4.1.2** Do you think the code below will compile? If so, what happens when it runs?

```java
public static void main(String[] args) {
    List61B<String> someList = new SLList<String>();
    someList.addFirst("elk");
}
```

Here are possible answers:

- Will not compile.
- Will compile, but will cause an error on the **new** line
- When it runs, an SLList is created and its address is stored in the someList variable, but it crashes on someList.addFirst() since the List class doesn't implement addFirst;
- When it runs, and SLList is created and its address is stored in the someList variable. Then the string "elk" is inserted into the SLList referred to by addFirst.

> 答案是最后一个, 既可以创建, 又可以调用

## Implementation Inheritance

Previously, we had an interface List61B that only had method headers identifying **what** List61B's should do. But, now we will see that we can write methods in List61B that already have their implementation filled out. These methods identify **how** hypernyms of List61B should behave.

In order to do this, you must include the ==**`default` keyword in the method signature.(这样接口里就也可以有非抽象的方法)**(Java 8以后的新特性)==

> **==这种非抽象的方法会被所有的子类继承, 同时也可以被子类所override==**

If we define this method in List61B

```java
default public void print() {
    for (int i = 0; i < size(); i += 1) {
        System.out.print(get(i) + " ");
    }
    System.out.println();
}
```

==**然后，实现List61B类的所有对象都可以使用该方法！**==

However, **there is one small inefficiency in this method.** Can you catch it?

For an SLList, the `get` method needs to jump through the entirety of the list. during each call. It's much better to just print while jumping through!

We want SLList to print a different way than the way specified in its interface. **To do this, we need to override it. In SLList, we implement this method;**

```java
@Override
public void print() {
    for (Node p = sentinel.next; p != null; p = p.next) {
        System.out.print(p.item + " ");
    }
}
```

Now, whenever we call print() on an SLList, it will call this method instead of the one in List61B.

You may be wondering, how does Java know which print() to call? Good question. Java is able to do this due to something called **==dynamic method selection(动态方法调度)==**.

We know that variables in java have a type.

```java
List61B<String> lst = new SLList<String>();
```

In the above declaration and instantiation, lst is of type "List61B". This is called the "==**static type**==" 在上述声明和实例化中，lst的类型为“List61B”。这被称为“静态类型”

However, the objects themselves have types as well. the object that lst points to is of type SLList. Although this object is intrinsically an SLList (since it was declared as such), it is also a List61B, because of the “is-a” relationship we explored earlier. But, because the object itself was instantiated using the SLList constructor, We call this its "==**dynamic type**==".   然而，对象本身也有类型。lst指向的对象类型为SLList。尽管这个对象本质上是一个SLList（因为它是这样声明的），但它也是一个List61B，这是因为我们前面讨论过的“is-a”关系。但是，因为对象本身是使用SLList构造函数实例化的，所以我们将其称为“==**动态类型**==”。

Aside: the name “dynamic type” is actually quite semantic in its origin! Should lst be reassigned to point to an object of another type, say a AList object, lst’s dynamic type would now be AList and not SLList! It’s dynamic because it changes based on the type of the object it’s currently referring to.

When Java runs a method that is overriden, it searches for the appropriate method signature in it's **dynamic type** and runs it.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230124231200226.png" alt="image-20230124231200226" style="zoom: 33%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230124231220001.png" alt="image-20230124231220001" style="zoom:33%;" />

> **==静态类型(编译的时候生成), 永远不能改变==**
>
> **==动态类型(运行时生成的类型): 实例化的时候赋予, 可以改变==**

> 最关键的一句话是**==如果Y覆盖了X的方法, 那么用Y的, 否则用X的==**

**==IMPORTANT: This does not work for overloaded methods! 但是对于重载的方法就不适用==**

Say there are two methods in the same class.

```java
public static void peek(List61B<String> list) {
    System.out.println(list.getLast());
}
public static void peek(SLList<String> list) {
    System.out.println(list.getFirst());
}
```

and you run this code

```java
SLList<String> SP = new SLList<String>();
List61B<String> LP = SP;
SP.addLast("elk");
SP.addLast("are");
SP.addLast("cool");
peek(SP);
peek(LP);
```

The first call to peek() will use the second peek method that takes in an SLList. The second call to peek() will use the first peek method which takes in a List61B. This is because the only distinction between two overloaded methods is the types of the parameters. When Java checks to see which method to call, ==it checks the **static type**== and calls the method with the parameter of the same type. **==重载的时候决定用哪个时, 检查的是静态类型(我猜的因为编译的时候就要决定这个!!!!!!)==**



补充: ***详见Dics 5***

 ==**编译器要在编译之前就做各种检查, 包括这个静态类型里有没有你要调用的这样方法, 所以"动态方法替换"成立的前提是, 静态类型的方法里有这个方法(非常重要!!!!!!)**==



## Interface Inheritance vs Implementation Inheritance 接口继承 vs 实现继承

How do we differentiate between "interface inheritance" and "implementation inheritance"? Well, you can use this simple distinction: 我们如何区分“接口继承”和“实现继承”？嗯，你可以使用这个简单的区别：

- Interface inheritance (what): Simply tells what the subclasses should be able to do.接口继承（what）：简单地告诉子类应该能够做什么
  - EX) all lists should be able to print themselves, how they do it is up to them.所有列表都应该能够自己打印，如何打印取决于他们。
- Implementation inheritance (how): Tells the subclasses how they should behave.实现继承（how）：告诉子类应该如何行为。
  - EX) Lists should print themselves exactly this way: by getting each element in order and then printing them.EX）列表应该完全按照这样的方式打印：按顺序排列每个元素，然后打印它们。

When you are creating these hierarchies, remember that the relationship between a subclass and a superclass should be an "is-a" relationship. AKA Cat should only **implement** Animal Cat **==is an==** Animal. You should not be defining them using a "has-a" relationship. Cat **==has-a==** Claw, but Cat definitely should not be implementing Claw.

> **==补充 : 接口继承时, 可以继承多个接口, 如`public class C implements A,B`==**

Finally, Implementation inheritance may sound nice and all but there are some drawbacks:**最后，实现继承可能听起来不错，但也有一些缺点：**

- We are fallible humans, and we can't keep track of everything, so it's possible that you overrode a method but forgot you did.我们是易犯错误的人，我们无法跟踪所有的事情，所以有可能你高估了一种方法，但忘记了你做了。

- It may be hard to resolve conflicts in case two interfaces give conflicting default methods.如果两个接口给出了冲突的默认方法，则可能很难解决冲突。

- It encourages overly complex code 它鼓励过度复杂的代码 

  ## What's Next?

- [Discussion 4 Inheritance](https://sp19.datastructur.es/materials/discussion/disc04.pdf)



# Extends, Casting, Higher Order Functions

## Extends

Now you've seen how we can use the `implements` keyword to define a hierarchical relationship with interfaces. What if we wanted to define a hierarchical relationship between classes?==现在您已经了解了如何使用**“implements”关键字来定义与接口的层次关系**。**如果我们想定义类之间的层次关系呢**？==

假设我们要构建一个RotatingSList，它具有与SLList相同的功能，如“`addFirst`”、“`size`”等，但具有一个附加的“`rotateRight`”操作，将最后一个项目放到列表的前面。

One way you could do this would be to copy and paste all the methods from SLList and write `rotateRight` on top of it all - but then we wouldn't be taking advantage of the power of inheritance! Remember that inheritance allows subclasses to *reuse* code from an already defined class. So let's define our RotatingSLList class to inherit from SLList.可以这样做的一种方法是复制并粘贴SLList中的所有方法，并在其上面写上“rotateRight”，但这样我们就不会利用继承的力量了！记住，继承允许子类“重用”已经定义的类中的代码。因此，让我们定义要从SLList继承的RotatingLList类。

We can set up this inheritance relationship in the class header, using the `extends` keyword like so:

```java
public class RotatingSLList<Item> extends SLList<Item>
```

In the same way that AList shares an "is-a" relationship with List61B, RotatingSLList shares an "is-a" relationship SLList. The `extends` keyword lets us keep the original functionality of SLList, while enabling us to make modifications and add additional functionality.

<img src="https://joshhug.gitbooks.io/hug61b/content/assets/list_subclasses.png" alt="img" style="zoom:50%;" />

Now that we've defined our RotatingSLList to extend from SLList, let's give it its unique ability to rotate.

**Exercise 4.2.1.** Define the `rotateRight` method, which takes in an existing list, and rotates every element one spot to the right, moving the last item to the front of the list.

For example, calling `rotateRight` on [5, 9, 15, 22] should return [22, 5, 9, 15].

*Tip: are there any inherited methods that might be helpful in doing this?*

Here's what we came up with.

```java
public void rotateRight() {
    Item x = removeLast();
    addFirst(x);
}
```

You might have noticed that we were able to use methods defined outside of RotatingSLList, because we used the `extends` keyword to inherit them from SLList. That gives rise to the question: What exactly do we inherit?

By using the `extends` keyword, subclasses inherit ==all **members**== of the parent class. "Members" includes:

- **All instance and static variables**
- **All methods**
- ==**All nested classes**==

**Note that constructors are not inherited, and private members cannot be directly accessed by subclasses. ==注意构造函数不是继承的，私有成员不能被子类直接访问。==**

### VengefulSLList

We create a new class, VengefulSLList, that remembers all items that have been banished by `removeLast`.

Like before, we specify in VengefulSLList's class header that it should inherit from SLList.

```java
public class VengefulSLList<Item> extends SLList<Item>
```

Now, let's give VengefulSLList a method to print out all of the items that have been removed by a call to the `removeLast` method, `printLostItems()`. We can do this by adding an instance variable that can keep track of all the deleted items. If we use an SLList to keep track of our items, then we can simply make a call to the `print()` method to print out all the items.

So far this is what we have:

```java
public class VengefulSLList<Item> extends SLList<Item> {
    SLList<Item> deletedItems;

    public void printLostItems() {
        deletedItems.print();
    }
}
```

VengefulSLList's `removeLast` should do exactly the same thing that SLList's does, except with one additional operation - adding the removed item to the `deletedItems` list. In an effort to *reuse* code, we can **override** the `removeLast` method to modify it to fit our needs, and call the `removeLast` method defined in the parent class, SLList, using the `super` keyword.

**Exercise 4.2.2.** Override the `removeLast` method to remove the last item, add that item to the `deletedItems` list, then return it.

Finally, VengefulSLList remembers all items deleted from it, as intended.

```java
public class VengefulSLList<Item> extends SLList<Item> {
    SLList<Item> deletedItems;

    public VengefulSLList() {
        deletedItems = new SLList<Item>();
    }

    @Override
    public Item removeLast() {
        Item x = super.removeLast();
        deletedItems.addLast(x);
        return x;
    }

    /** Prints deleted items. */
    public void printLostItems() {
        deletedItems.print();
    }
}
```

> ==新知识点 : super表示父类==

### Constructors Are Not Inherited 构造函数不继承

As we mentioned earlier, subclasses inherit all members of the parent class, which includes instance and static variables, methods, and nested classes, **but does *not* include constructors.**

While constructors are not inherited, Java requires that all constructors **==must start with a call to one of its superclass's constructors==**.

To gain some intuition on why that it is, recall that the `extends` keywords defines an "is-a" relationship between a subclass and a parent class. If a VengefulSLList "is-an" SLList, then it follows that every VengefulSLList must be set up like an SLList.

Here's a more in-depth explanation. Let's say we have two classes:

```java
public class Human {...}
public class TA extends Human {...}
```

It is logical for TA to extend Human, because all TA's are Human. Thus, we want TA's to inherit the attributes and behaviors of Humans.

If we run the code below:

```
TA Christine = new TA();
```

Then first, a Human must be created. Then, that Human can be given the qualities of a TA. It doesn't make sense for a TA to be constructed without first creating a Human first.

Thus, we can either explicitly make a call to the superclass's constructor, using the `super` keyword:

```java
public VengefulSLList() {
    super();
    deletedItems = new SLList<Item>();
}
```

Or, if we choose not to, Java will automatically make a call to the superclass's *no-argument* constructor for us.

In this case, adding `super()` has no difference from the constructor we wrote before. It just makes explicit what was done implicitly by Java before. However, if we were to define another constructor in VengefulSLList, Java's implicit call may not be what we intend to call.

Suppose we had a one-argument constructor that took in an item. If we had relied on an implicit call to the superclass's *no-argument* constructor, `super()`, the item passed in as an argument wouldn't be placed anywhere!

So, we must make an explicit call to the correct constructor by passing in the item as a parameter to super.

```java
public VengefulSLList(Item x) {
    super(x);
    deletedItems = new SLList<Item>();
}
```

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230125112103013.png" alt="image-20230125112103013" style="zoom: 33%;" />

> **==如果我们不显式的调用super(), 系统也会帮我们这样做, 但是系统默认的是调用不带参数的父类的构造函数, 所以当需要传入参数时, 我们必须手动调用==**

### The Object Class

**Every class in Java is a descendant(后代) of the Object class, or `extends` the Object class**. Even classes that do not have an explicit `extends` in their class still *implicitly* extend the Object class.

For example,

- VengefulSLList `extends` SLList explicitly in its class declaration
- SLList `extends` Object implicitly(蕴含地)

This means that since SLList inherits all members of Object, VengefulSLList inherits all members of SLList ***==and==*** Object, transitively. So, what is to be inherited from Object?

As seen in the [documentation for the Object class](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html), the Object class provides operations that every Object should be able to do - like ==`.equals(Object obj)`, `.hashCode()`, and `toString()`.==

> ==注意 : `Object`类不是接口(Interface), 而是具体的已经实现的类(Class)==

### Is-a vs. Has-a

***Important Note:* The `extends` keyword defines "is-a", or hypernymic relationships. A common mistake is to instead use it for "has-a", or meronymic relationships.**

> **==千万不要弄混`is-a`和`has-a`==**

When extending a class, a wise thing to do would be to ask yourself if the "is-a" relationship makes sense.

- `Shower` is a `Bathroom`? No!
- `VengefulSLList` is a `SLList`? Yes!

## Encapsulation 封装

**封装是面向对象编程的基本原则之一**，也是我们程序员抵御最大敌人***复杂性(complexity)***的方法之一。**管理复杂性**是我们编写大型程序时必须面对的主要挑战之一。

Some of the tools we can use to fight complexity include hierarchical(分级的,等级的) abstraction (==**abstraction barriers**==!) and a concept known as "**==Design for change==**". This revolves around the idea that **programs should be built into modular**, interchangeable pieces that can be swapped around without breaking the system. Additionally, **==hiding information==** that others don't need is another fundamental approach when managing a large system.

封装的根源在于这种对外部隐藏信息的概念。观察它的一种方法是看封装是如何类似于人类细胞的。细胞的内部可能极其复杂，由染色体、线粒体、核糖体等组成，但它被完全封装在一个单一的模块中，从而消除了内部的复杂性。

![img](https://joshhug.gitbooks.io/hug61b/content/assets/cell_encapsulated.png)

在计算机科学术语中，模块可以被定义为一组方法，它们作为一个整体一起工作以执行一项任务或一组相关任务。这可能类似于表示列表的类。现在，如果一个模块的实现细节被隐藏在内部，并且与之交互的唯一方式是通过一个文档化的接口，那么这个模块就被称为是封装的。

以“`ArrayDeque`”类为例。外部世界能够通过定义的方法（如“`addLast`”和“`removeLast`”）利用“`ArrayDeque`”并与之交互。然而，他们不需要了解如何实现数据结构的复杂细节，以便能够有效地使用它。

### Abstraction Barriers 抽象界限

理想情况下，用户不应该能够观察到他们正在使用的数据结构的内部工作。幸运的是，Java可以很容易地实施抽象障碍。在Java中使用“private”关键字，几乎不可能查看对象内部，从而确保底层复杂性不会暴露于外部世界。

### How Inheritance Breaks Encapsulation 继承是如何打破封装的

Suppose we had the following two methods in a Dog class. We could have implemented `bark` and `barkMany` like so:

```java
public void bark() {
    System.out.println("bark");
}

public void barkMany(int N) {
    for (int i = 0; i < N; i += 1) {
        bark();
    }
}
```

Or, alternatively, we could have implemented it like so:

```java
public void bark() {
    barkMany(1);
}

public void barkMany(int N) {
    for (int i = 0; i < N; i += 1) {
        System.out.println("bark");
    }
}
```

From a user's perspective, the functionality of either of these implementations is exactly the same. However, observe the effect if we were to define a a subclass of `Dog` called `VerboseDog`, and override its `barkMany` method as such:

```java
@Override
public void barkMany(int N) {
    System.out.println("As a dog, I say: ");
    for (int i = 0; i < N; i += 1) {
        bark();
    }
}
```

**Exercise 4.2.3.** Given a VerboseDog `vd`, what would `vd.barkMany(3)` output, given the first implementation above? The second implementation?

- a: As a dog, I say: bark bark bark
- b: bark bark bark
- c: Something else

As you have seen, using the first implementation, the output is A, while using the second implementation, the program gets caught in an infinite loop. The call to `bark()` will call `barkMany(1)`, which makes a call to `bark()`, *repeating the process infinitely many times.*

> 这就是继承的缺点, 有可能会像这样打破抽象界限

## Type Checking and Casting 类型检查与类型转换

Before we go into types and casting, let's review **dynamic method selection**. Recall that dynamic method lookup is the process of determining the method that is executed at runtime based on the dynamic type of the object. Specifically, if a method in SLList is overridden by the VengefulSLList class, then the method that is called at runtime is determined by the run-time type, or dynamic type, of that variable.

**Exercise 4.2.4.** For each line of code below, decide the following:

- Does that line cause a compilation error?
- Which method uses dynamic selection?

<img src="https://joshhug.gitbooks.io/hug61b/content/assets/dynamic_selection.png" alt="img" style="zoom:33%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230125123006832.png" alt="image-20230125123006832" style="zoom: 33%;" />

> vsl `is-a` SLL, 所以可以绑定

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230125123117714.png" alt="image-20230125123117714" style="zoom:33%;" />

> ==**s1的静态类型中没有printLostItem, 所以不能编译通过(编译时就会出错, 编译器会进行尽可能安全的类型检查)**==
>
> ==第二行出错是因为不符合`is-a`的关系, **即使动态类型符合也不行, 因为编译器检查的是静态类型**==



> ==总结(学完这章以后)动态方法选择 : 首先要在**static type**里看看有没有这个方法签名, 如果有, 可以通过 **编译**,==
>
> ==但在实际的run-time时, 会考虑"Can we do better ?" ,会从**实际的对象类型(dynamic type)开始往上面找**, 看看有没有符合方法签名的, 一旦符合, 就调用(**中间的类也可以**).==
>
> > **==在run-time时,即使子类里有更好的(更符合的),也不选, 因为我们只会看有没有我们"最初锁定的那个签名的更better的", 不会考虑"其他有没有更better"的==**
> >
> > 具体看Disc6 1.a

### Expressions

Like variables as seen above, expressions using the `new` keyword also have compile-time types.

```java
SLList<Integer> sl = new VengefulSLList<Integer>();
```

Above, the compile-time type of the right-hand side of the expression is VengefulSLList. **==The compiler checks to make sure that VengefulSLList "is-a" SLList, and allows this assignment,==**

```java
VengefulSLList<Integer> vsl = new SLList<Integer>();
```

Above, the compile-time type of the right-hand side of the expression is SLList. The compiler checks if SLList "is-a" VengefulSLList, which it is not in all cases, and thus a compilation error results.

Further, method calls have compile-time types equal to their declared type. Suppose we have this method:

```java
public static Dog maxDog(Dog d1, Dog d2) { ... }
```

**==Since the return type of `maxDog` is Dog, any call to `maxDog` will have compile-time type Dog (关于函数的)==.**

```java
Poodle frank = new Poodle("Frank", 5);
Poodle frankJr = new Poodle("Frank Jr.", 15);

Dog largerDog = maxDog(frank, frankJr);
Poodle largerPoodle = maxDog(frank, frankJr); //does not compile! RHS has compile-time type Dog
```

Assigning a Dog object to a Poodle variable, like in the SLList case, results in a compilation error. A Poodle "is-a" Dog, but a more general Dog object may not always be a Poodle, even if it clearly is to you and me (we know that `frank` and `frankJr` are both Poodles!). **Is there any way around this, when we know for certain that assignment would work? (是下边要讲的)**

### Casting

Java has a special syntax where you can tell the compiler that a specific expression has a specific compile-time type. **==This is called "casting". With casting, we can tell the compiler to view an expression as a different compile-time type.==**

Looking back at the code that failed above, since we know that `frank` and `frankJr` are both Poodles, we can cast:

```java
Poodle largerPoodle = (Poodle) maxDog(frank, frankJr); // compiles! Right hand side has compile-time type Poodle after casting
```

==***Caution*: Casting is a powerful but dangerous tool. Essentially, casting is telling the compiler not to do its type-checking duties - telling it to trust you and act the way you want it to. Here's a possible issue that could arise:**==

***警告*：铸造是一种强大但危险的工具。从本质上讲，==强制转换是告诉编译器不要执行其类型检查职责==——告诉编译器信任您并按照您希望的方式行事。可能会出现以下问题：**

```java
Poodle frank = new Poodle("Frank", 5);
Malamute frankSr = new Malamute("Frank Sr.", 100);

Poodle largerPoodle = (Poodle) maxDog(frank, frankSr); // runtime exception!
```

In this case, we compare a Poodle and a Malamute. Without casting, the compiler would normally not allow the call to `maxDog` to compile, as the right hand side compile-time type would be Dog, not Poodle. However, casting allows this code to pass, and when `maxDog` returns the Malamute at runtime, and **we try casting a Malamute as a Poodle, we run into a runtime exception - a `ClassCastException`.**

> 总结 : 类型转化 就是告诉 编译器 , "相信我, 这样做不会出错的" (实际出不出错就不好说了)

## Higher Order Functions 高阶函数 HoF

稍微绕道，我们将介绍更高阶的函数。**==高阶函数是将其他函数视为数据的函数==**。例如，以这个Python程序“do_twice”为例，它接受另一个函数作为输入，并将其应用于输入“x”两次。

```python
def tenX(x):
    return 10*x

def do_twice(f, x):
    return f(f(x))
```

A call to `print(do_twice(tenX, 2))` would apply tenX to 2, and apply tenX again to its result, 20, resulting in 200. How would we do something like this in Java?

**在老式Java（Java7和更早版本）中，内存盒（变量）不能包含指向函数的指针**。这意味着我们无法编写具有“function”类型的函数，因为函数根本没有类型。

To get around this we can take advantage of **interface inheritance**. Let's write an interface that defines any function that takes in an integer and returns an integer - an `IntUnaryFunction`.==为了解决这个问题，我们可以利用**接口继承**==。让我们编写一个接口，它定义任何接受整数并返回整数的函数，即“IntUnaryFunction”。

```java
public interface IntUnaryFunction {
    int apply(int x);
}
```

Now we can write a class which `implements IntUnaryFunction` to represent a concrete function. Let's make a function that takes in an integer and returns 10 times that integer.

```java
public class TenX implements IntUnaryFunction {
    /* Returns ten times the argument. */
    public int apply(int x) {
        return 10 * x;
    }
}
```

At this point, we've written in Java the Python equivalent of the `tenX` function. Let's write `do_twice` now.

```java
public static int do_twice(IntUnaryFunction f, int x) {
    return f.apply(f.apply(x)); // 这是在另一个class里面
}
```

A call to `print(do_twice(tenX, 2))` in Java would look like this:

```java
System.out.println(do_twice(new TenX(), 2));
```

### Inheritance Cheatsheet 继承闲聊 (一个小总结)

`VengefulSLList extends SLList` means VengefulSLList "is-an" SLList, and inherits all of SLList's members:

- Variables, methods nested classes
- Not constructors Subclass constructors must invoke superclass constructor first. The `super` keyword can be used to invoke overridden superclass methods and constructors.

Invocation of overridden methods follows two simple rules:

- **Compiler plays it safe and only allows us to do things according to the static type.**
- **For overridden methods (*not overloaded methods*), the actual method invoked is based on the dynamic type of the invoking expression**
- **Can use casting to overrule compiler type checking.**

自己总结:

- ==从子类到父类的类型可以**自动进行**==
- ==从父类到子类的类型转换必须通过造型（**强制类型转换**）实现==
- ==无继承关系的引用类型间的转换是**非法的**==



# Subtype Polymorphism vs HOFs

## Subtype Polymorphism 子类型多态

We've seen how inheritance lets us reuse existing code in a superclass while implementing small modifications by overriding a superclass's methods or writing brand new methods in the subclass. **Inheritance also makes it possible to design general data structures and methods using *polymorphism*.**

**Polymorphism, at its core, means 'many forms'**. In Java, polymorphism refers to how objects can have many forms or types. In object-oriented programming, polymorphism relates to how an object can be regarded as an instance of its own class, an instance of its superclass, an instance of its superclass's superclass, and so on.

考虑静态类型deque的变量“`deque`”。根据调用“`addFirst`”时“`deque`”的运行时类型或动态类型，将在执行时确定对“`deque.addFirst()`”的调用。正如我们在上一章中看到的，Java使用动态方法选择来选择要调用的方法。

假设我们想编写一个python程序，打印两个对象中较大对象的字符串表示。对此有两种方法。

1. Explicit HoF Approach 显式HoF方法

```python
def print_larger(x, y, compare, stringify):
    if compare(x, y):
        return stringify(x)
    return stringify(y)
```

1. Subtype Polymorphism Approach

```python
def print_larger(x, y):
    if x.largerThan(y):
        return x.str()
    return y.str()
```

Using the explicit higher order function approach, you have a common way to print out the larger of two objects. In contrast, in the subtype polymorphism approach, the object *itself* makes the choices. The `largerFunction` that is called is dependent on what x and y actually are.使用显式的高阶函数方法，可以用一种常见的方法打印出两个对象中较大的一个。相反，**在子类型多态方法中，对象*本身*做出选择。调用的“largerFunction”取决于x和y的实际值**。

### Max Function

Say we want to write a `max` function which takes in any array - regardless of type - and returns the maximum item in the array.

**Exercise 4.3.1.** Your task is to determine how many compilation errors there are in the code below.

```java
public static Object max(Object[] items) {
    int maxDex = 0;
    for (int i = 0; i < items.length; i += 1) {
        if (items[i] > items[maxDex]) {
            maxDex = i;
        }
    }
    return items[maxDex];
}

public static void main(String[] args) {
    Dog[] dogs = {new Dog("Elyse", 3), new Dog("Sture", 9), new Dog("Benjamin", 15)};
    Dog maxDog = (Dog) max(dogs);
    maxDog.bark();
}
```

In the code above, there was only 1 error, found at this line:

```java
if (items[i] > items[maxDex]) {
```

这导致编译错误的原因是，这一行假定“>”运算符可用于任意Object类型，而实际上不适用。

Instead, one thing we could is define a `maxDog` function in the Dog class, and give up on writing a "one true max function" that could take in an array of any arbitrary type. We might define something like this:

```java
public static Dog maxDog(Dog[] dogs) {
    if (dogs == null || dogs.length == 0) {
        return null;
    }
    Dog maxDog = dogs[0];
    for (Dog d : dogs) {
        if (d.size > maxDog.size) {
            maxDog = d;
        }
    }
    return maxDog;
}
```

> 但这只适用于`Dog`, 我们想编写一个通用的

The fundamental issue that gives rise to this is that Objects cannot be compared with `>`. This makes sense, as how could Java know whether it should use the String representation of the object, or the size, or another metric, to make the comparison? **In Python or C++, the way that the `>` operator works could be redefined to work in different ways when applied to different types. Unfortunately, Java does not have this capability. Instead, we turn to ==interface inheritance== to help us out.**

We can create an interface that guarantees that any implementing class, like Dog, contains a comparison method, which we'll call `compareTo`.

<img src="https://joshhug.gitbooks.io/hug61b/content/assets/dog_comparable.png" alt="img" style="zoom: 50%;" />

Let's write our interface. We'll specify one method ==`compareTo`==.

```java
public interface OurComparable {
    public int compareTo(Object o);
}
```

We will define its behavior like so:

- Return -1 if `this` < o.
- Return 0 if `this` equals o.
- Return 1 if `this` > o.

Now that we've created the `OurComparable` interface, we can require that our Dog class implements the `compareTo` method. First, we change Dog's class header to include `implements OurComparable`, and then we write the `compareTo` method according to its defined behavior above.

**Exercise 4.3.2.** Implement the `compareTo` method for the Dog class.

We use the instance variable `size` to make our comparison.

```java
public class Dog implements OurComparable {
    private String name;
    private int size;

    public Dog(String n, int s) {
        name = n;
        size = s;
    }

    public void bark() {
        System.out.println(name + " says: bark");
    }

    public int compareTo(Object o) {
        Dog uddaDog = (Dog) o;
        if (this.size < uddaDog.size) {
            return -1;
        } else if (this.size == uddaDog.size) {
            return 0;
        }
        return 1;
    }
}
```

**==Notice that since `compareTo` takes in any arbitrary Object o, we have to *cast* the input to a Dog to make our comparison using the `size` instance variable.==**

Now we can generalize the `max` function we defined in exercise 4.3.1 to, instead of taking in any arbitrary array of objects, takes in `OurComparable` objects - which we know for certain all have the `compareTo` method implemented.

```java
public static OurComparable max(OurComparable[] items) {
    int maxDex = 0;
    for (int i = 0; i < items.length; i += 1) {
        int cmp = items[i].compareTo(items[maxDex]);
        if (cmp > 0) {
            maxDex = i;
        }
    }
    return items[maxDex];
}
```

Great! Now our `max` function can take in an array of any `OurComparable` type objects and return the maximum object in the array. Now, this code is admittedly quite long, so we can make it much more succinct by modifying our `compareTo` method's behavior:

- Return negative number if `this` < o.
- Return 0 if `this` equals o.
- Return positive number if `this` > o.

Now, we can just return the difference between the sizes. If my size is 2, and uddaDog's size is 5, `compareTo` would return -3, a negative number indicating that I am smaller.

```java
public int compareTo(Object o) {
    Dog uddaDog = (Dog) o;
    return this.size - uddaDog.size;
}
```

Using inheritance, we were able to generalize our maximization function. What are the benefits to this approach?

- No need for maximization code in every class(i.e. no `Dog.maxDog(Dog[])` function required
- We have code that operates on multiple types (mostly) gracefully

### Interfaces Quiz

**Exercise 4.3.3.** 

```java
public class DogLauncher {
    public static void main(String[] args) {
        ...
        Dog[] dogs = new Dog[]{d1, d2, d3};
        System.out.println(Maximizer.max(dogs));
    }
}

public class Dog implements OurComparable {
    ...
    public int compareTo(Object o) {
        Dog uddaDog = (Dog) o;
        if (this.size < uddaDog.size) {
            return -1;
        } else if (this.size == uddaDog.size) {
            return 0;
        }
        return 1;
    }
    ...
}

public class Maximizer {
    public static OurComparable max(OurComparable[] items) { // 可以这样, 因为Dog是OurComparable 的子类
        ...
        int cmp = items[i].compareTo(items[maxDex]);
        ...
    }
}
```

==**以下这道思考题很重要**==

给定“`Dog`”类、“`DogLauncher`”类、‘`OurComparable`’接口和‘`Maximizer`’类，如果省略Dog类中的`compareTo()`方法，哪个文件将无法编译？

答案:  In this case, the `Dog` class fails to compile. By declaring that it `implements OurComparable`, the Dog class makes a claim that it "is-an" OurComparable. As a result, the compiler checks that this claim is actually true, but sees that Dog doesn't implement `compareTo`.

如果我们从Dog类头中省略了“`implements OurComparable`”怎么办？

答案: 这将导致DogLauncher中的编译错误，原因如下：

```java
System.out.println(Maximizer.max(dogs));
```

如果Dog没有实现OurComparable接口，那么试图将Dog数组传递给Maximizer的“`max`”函数将不会得到编译器的批准`max`只接受OurComparable对象的数组。

**==思考题结束==**

## Comparables

我们刚刚构建的“`OurComparable`”接口可以工作，但并不完美。这里有一些问题：

- Awkward casting to/from Objects 向对象/从对象进行尴尬投射
- We made it up. 我们编的。
  - No existing classes implement OurComparable (e.g. String, etc.)没有现有的类实现OurComparable（例如String等）
  - No existing classes use OurComparable (e.g. no built-in max function that uses OurComparable) 没有现有类使用OurComparable（例如，没有使用OurComparable的内置max函数）

解决方案？**==我们将利用已经存在的名为“`Comparable`”的接口`Comparable`‘已经由Java定义，并被无数的库使用==。**

`Comparable` looks very similar to the OurComparable interface we made, but with one main difference. Can you spot it?

![img](https://joshhug.gitbooks.io/hug61b/content/assets/comparable_interface.png)

Notice that `Comparable<T>` means that it takes **a generic type**. This will help us avoid having to cast an object to a specific type! Now, we will rewrite the Dog class to implement the Comparable interface, being sure to update the generic type `T` to Dog:

```java
public class Dog implements Comparable<Dog> {
    ...
    public int compareTo(Dog uddaDog) {
        return this.size - uddaDog.size;
    }
}
```

Now all that's left is to change each instance of OurComparable in the Maximizer class to Comparable. Watch as the largest Dog says bark:

Instead of using our personally created interface `OurComparable`, we now use the real, built-in interface, `Comparable`. As a result, we can take advantage of all the libraries that already exist and use `Comparable`.

<img src="https://joshhug.gitbooks.io/hug61b/content/assets/comparable.png" alt="img" style="zoom:50%;" />

## Comparator

我们刚刚了解了类似的界面，它嵌入了每只狗与另一只狗进行比较的能力。现在，我们将介绍一个看起来非常类似的新接口，名为“`Comparator`”。

Let's start off by defining some terminology(术语).

- **Natural order** - used to refer to the ordering implied in the `compareTo` method of a particular class.

例如，正如我们前面所述，狗的自然顺序是根据大小的值来定义的。如果我们想以不同于它们自然排序的方式对狗进行排序，比如按照它们名字的字母顺序，会怎么样？

Java的实现方法是使用“`Comparator`”。由于比较器是一个对象，所以我们使用“`comparator`”的方式是在Dog中编写一个实现“`comparator`'接口的嵌套类。

But first, what's inside this interface?

```java
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

This shows that the `Comparator` interface requires that any implementing class implements the `compare` method. The rule for `compare` is just like `compareTo`:

- Return negative number if o1 < o2.
- Return 0 if o1 equals o2.
- Return positive number if o1 > o2.

Let's give Dog a NameComparator. To do this, we can simply defer to `String`'s already defined `compareTo` method.

```java
import java.util.Comparator;

public class Dog implements Comparable<Dog> {
    ...
    public int compareTo(Dog uddaDog) {
        return this.size - uddaDog.size;
    }

    private static class NameComparator implements Comparator<Dog> {
        public int compare(Dog a, Dog b) {
            return a.name.compareTo(b.name);
        }
    } //建立一个嵌套的class,这是我们需要做的

    public static Comparator<Dog> getNameComparator() {
        return new NameComparator();
    }
}
```

> ==**建立一个嵌套的class**==

**==Note that we've declared NameComparator to be a static class==**. 一个小的区别，但我们这样做是因为我们不需要实例化Dog来获得NameComparator。让我们看看这个比较器是如何工作的。

As you've seen, we can retrieve our NameComparator like so:

```java
Comparator<Dog> nc = Dog.getNameComparator();
```

All in all, we have a Dog class that has a private NameComparator class and a method that returns a NameComparator we can use to compare dogs alphabetically by name.

Let's see how everything works in the inheritance hierarchy - we have a Comparator interface that's built-in to Java, which we can implement to define our own Comparators (`NameComparator`, `SizeComparator`, etc.) within Dog.

![img](https://joshhug.gitbooks.io/hug61b/content/assets/comparator.png)

To summarize, ==interfaces in Java provide us with the ability to make **callbacks**.== Sometimes, a function needs the help of another function that might not have been written yet (e.g. `max` needs `compareTo`). **A callback function is the helping function (in the scenario, `compareTo`). In some languages, this is accomplished using explicit function passing; in Java, we wrap the needed function in an interface.**

==A Comparable says, "I want to compare myself to another object". **It is imbedded(嵌入) within the object itself**, and it defines the **natural ordering** of a type==. ==A Comparator, on the other hand, is more like a third party machine that compares two objects to each other==. **Since there's only room for one `compareTo` method, if we want multiple ways to compare, we must turn to Comparator.**