# Testing and Selection Sort 测试与选择排序

中级到高级(intermediate to advanced)程序员最重要的技能之一是判断代码何时正确。在本章中，我们将讨论如何编写测试来评估代码正确性。在此过程中，我们还将讨论一种称为“选择排序”的排序算法。

## A New Way

编写程序时，可能会出错。在课堂环境中，通过用户交互、代码分析和自动签名测试的组合，您可以对代码的正确性充满信心，在很多情况下，最后一项最重要，尤其是您如何获得分数。

当然，自动阅卷机(autograder)不是魔法。它们是讲师编写的代码，与您编写的代码基本上没有什么不同。在现实世界中，这些测试是由程序员自己编写的，而不是像Josh Hug那样仁慈的第三方。

**In this chapter, we'll explore how we can write our own tests在本章中，我们将探讨如何编写自己的测试**. Our goal will be to create a class called `Sort` that provides a method `sort(String[] x)` that destructively sorts the strings in the array `x`.我们的目标是创建一个名为“Sort”的类，该类提供一个方法“Sort（String[]x）”，该方法对数组“x”中的字符串进行破坏性排序。

As a totally new way of thinking, we'll start by writing `testSort()` first, and only after we've finished the test, we'll move on to writing the actual sorting code.

## Ad Hoc Testing 临时测试, 随机测试

> wiki : 从英文翻译而来-临时测试是在没有初始测试用例文档的情况下执行的计划软件测试的常用术语。但是，临时测试也可以应用于其他科学研究和质量控制工作。临时测试对于增加最终产品或流程的信心以及快速发现重要的缺陷或低效率很有用，但是它们也有一些缺点，例如性能存在固有的不确定性，并且没有适当的文档记录就没有用处。执行和完成。

为“Sort.Sort”编写测试相对简单，尽管很乏味。我们只需要创建一个输入，调用“sort”，并检查方法的输出是否正确。如果输出不正确，我们打印出第一个不匹配并终止测试。例如，我们可以创建如下测试类：

```java
public class TestSort {
    /** Tests the sort method of the Sort class. */
    public static void testSort() {
        String[] input = {"i", "have", "an", "egg"};
        String[] expected = {"an", "egg", "have", "i"};
        Sort.sort(input);
        for (int i = 0; i < input.length; i += 1) {
            if (!input[i].equals(expected[i])) {
                System.out.println("Mismatch in position " + i + ", expected: " + expected + ", but got: " + input[i] + ".");
                break;
            }
        }
    }

    public static void main(String[] args) {
        testSort();
    }
}
```

We can test out our test by creating a blank `Sort.sort` method as shown below:

```java
public class Sort {
    /** Sorts strings destructively. */
    public static void sort(String[] x) {        
    }
}
```

If we run the `testSort()` method with this blank `Sort.sort` method, we'd get:

```sh
Mismatch in position 0, expected: an, but got: i.
```

事实上，我们收到错误消息是一件好事！这意味着我们的测试正在进行。非常有趣的是，我们现在为自己创建了一个小游戏，目的是修改`Sort.Sort`的代码，以便不再出现此错误消息。这是一种心理把戏，但许多程序员发现为自己制作这些小谜题几乎会上瘾。

> 你可以自己建立test, 从而让你像被autograder吸引一样被test吸引

**重要提示：**您可能会问“为什么要在整个数组中循环？为什么不使用`==`检查数组是否相等？”。原因是，当我们测试两个对象的相等性时，我们不能简单地使用`==`运算符。==**`==`运算符比较存储框(memory boxes)中的文字位(literal bits)，例如`input==expected`将测试`input`和`expectd`的地址是否相同，而不是数组中的值是否相同。**==相反，我们在`testSort`中使用了一个循环，并打印出第一个不匹配项。您还可以使用内置方法`java.util.Arrays.equals`而不是循环。

While the single test above wasn't a ton of work, **writing a suite of such *ad hoc* tests would be very tedious(单调乏味的)**, as it would entail(涉及, 需要) writing a bunch of different loops and print statements. **==In the next section, we'll see how the `org.junit` library saves us a lot of work.==**

## JUnit Testing

The `org.junit` library provides a number of helpful methods and useful capabilities for simplifying the writing of tests. For example, we can replace our simple *ad hoc* test from above with:

```java
public static void testSort() {
    String[] input = {"i", "have", "an", "egg"};
    String[] expected = {"an", "egg", "have", "i"};
    Sort.sort(input);
    org.junit.Assert.assertArrayEquals(expected, input);
}
```

**这段代码要简单得多**，**并且或多或少做了完全相同的事情，即如果数组不相等，它将告诉我们第一个不匹配**。例如，如果我们对一个“Sort.Sort”方法运行“testSort（）”，但该方法不执行任何操作，则会得到：

```sh
Exception in thread "main" arrays first differed at element [0]; expected:<[an]> but was:<[i]>
    at org.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:55)
    at org.junit.Assert.internalArrayEquals(Assert.java:532)
    ...
```

**虽然这个输出比我们的“临时”测试要难看一点，但我们将在本章末尾看到如何使其更好。**

## Selection Sort

在编写“Sort.Sort”方法之前，我们需要一些排序算法。也许最简单的排序算法是“选择排序”。选择排序包括三个步骤：

- Find the smallest item.找到最小的项目
- Move it to the front.把它移到前面。
- Selection sort the remaining N-1 items (without touching the front item).选择对剩余的N-1个项目进行排序(不接触前面的项目).

We could mathematically prove the correctness of this sorting algorithm on any arrays by using the concept of **==invariants(不变量)==** that **was originally introduced in chapter 2.4**, though we will not do so in this textbook. Before proceeding, try writing out your own short array of numbers and perform selection sort on it, so that you can make sure you get the idea.

Now that we know how selection sort works, we can write in a few short comments in our blank `Sort.sort` method to guide our thinking:

```java
public class Sort {
    /** Sorts strings destructively. */
    public static void sort(String[] x) { 
           // find the smallest item
           // move it to the front
           // selection sort the rest (using recursion?)
    }
}
```

在接下来的部分中，我将尝试完成选择排序的实现。我将以类似于学生处理问题的方式来完成，因此**我将在这一过程中犯一些故意错误**。这些故意的错误是一件好事，因为它们有助于证明测试的有用性。如果你在阅读时发现任何错误，不要担心，我们最终会纠正它们。

## findSmallest

最自然的开始是编写一个查找列表中最小项目的方法。与“`Sort.Sort`”一样，*我们将在完成方法*之前先编写一个测试。首先，我们将创建一个虚拟的“`findSmallest`”方法，它只返回一些任意值：

```java
public class Sort {
    /** Sorts strings destructively. */
    public static void sort(String[] x) { 
           // find the smallest item
           // move it to the front
           // selection sort the rest (using recursion?)
    }

    /** Returns the smallest string in x. */
    public static String findSmallest(String[] x) {
        return x[3];
    }
}
```

显然，这不是一个正确的实现，但我们选择将`findSmallest`如何工作的实际思考推迟到编写测试之后。使用“`org.junit`”库，将这样的测试添加到“`TestSort`”类非常简单，如下所示：

```java
public class TestSort {
    ...
    public static void testFindSmallest() {
        String[] input = {"i", "have", "an", "egg"};
        String expected = "an";

        String actual = Sort.findSmallest(input);
        org.junit.Assert.assertEquals(expected, actual);        
    }

    public static void main(String[] args) {
        testFindSmallest(); // note: we changed this from testSort!
    }
}
```

当我们运行“`TestSort.testFindSmallest`”时，会出现一个错误，这是一件好事：

```sh
Exception in thread "main" java.lang.AssertionError: expected:<[an]> but was:<[null]>
    at org.junit.Assert.failNotEquals(Assert.juava:834)
    at TestSort.testFindSmallest(TestSort.java:9)
    at TestSort.main(TestSort.java:24)
```

与之前一样，我们为自己设置了一个小游戏，现在我们的目标是修改“`Sort.findSmallest`”的代码，以便不再出现此错误。这是一个比让“`Sort.sort`”工作更小的目标，这可能会让人更上瘾。



接下来，我们开始实际编写“`findSmallest`”。这似乎应该相对简单。如果你是一个Java新手，你可能最终会编写类似这样的代码：

```java
/**  Returns the smallest string in x. */
public static String findSmallest(String[] x) {
    String smallest = x[0];
    for (int i = 0; i < x.length; i += 1) {
        if (x[i] < smallest) {
            smallest = x[i];
        }
    }
    return smallest;
}
```

However, this will yield the compilation error "< cannot be applied to 'java.lang.String'". **The issue is that Java does not allow comparisons between Strings using the < operator.**

When you're programming and get stuck on an issue like this that is easily describable, it's probably best to turn to a search engine. For example, we might search "less than strings Java" with Google. Such a search might yield a Stack Overflow post like [this one](https://stackoverflow.com/questions/5153496/how-can-i-compare-two-strings-in-java-and-define-which-of-them-is-smaller-than-t).

One of the popular answers for this post explains that the `str1.compareTo(str2)` method will return a negative number if `str1 < str2`, 0 if they are equal, and a positive number if `str1 > str2`.

Incorporating this into our code, we might end up with:

```java
/** Returns the smallest string in x. 
  * @source Got help with string compares from https://goo.gl/a7yBU5. */
public static String findSmallest(String[] x) {
    String smallest = x[0];
    for (int i = 0; i < x.length; i += 1) {
        int cmp = x[i].compareTo(smallest);
        if (cmp < 0) {
            smallest = x[i];
        }
    }
    return smallest;
}
```

请注意，我们使用了“@source”标记来引用我们的来源。我将以61B为正式课程的学生为例来说明这一点。这不是典型的现实世界做法。

由于我们使用的语法特性对我们来说是全新的，因此我们可能对“`findSmallest`”方法的正确性缺乏信心。幸运的是，我们不久前刚刚写了那个测试。如果我们尝试运行它，我们将看到没有打印任何内容，这意味着我们的代码可能是正确的。

我们可以通过增加更多的测试用例来增强我们的测试以增加我们的信心.例如,我们可以更改“`testFindSmallest`”，使其如下所示：

```java
public static void testFindSmallest() {
    String[] input = {"i", "have", "an", "egg"};
    String expected = "an";

    String actual = Sort.findSmallest(input);
    org.junit.Assert.assertEquals(expected, actual);        

    String[] input2 = {"there", "are", "many", "pigs"};
    String expected2 = "are";

    String actual2 = Sort.findSmallest(input2);
    org.junit.Assert.assertEquals(expected2, actual2);
}
```

Rerunning the test, we see that it still passes. We are not absolutely certain that it works, but we are much more certain that we would have been without any tests.

## Swap

Looking at our `sort` method below, the next helper method we need to write is something to move an item to the front, which we'll call `swap`.

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
       // find the smallest item
       // move it to the front
       // selection sort the rest (using recursion?)
}
```

编写“`swap`”方法非常简单，您可能以前也这样做过。正确的实现可能如下：

```java
public static void swap(String[] x, int a, int b) {
    String temp = x[a];
    x[a] = x[b];
    x[b] = temp;
}
```

然而，现在，让我们引入一个故意的错误，以便我们可以演示测试的实用性。一个更天真的程序员可能会做一些类似的事情：

```java
public static void swap(String[] x, int a, int b) {    
    x[a] = x[b];
    x[b] = x[a];
}
```

在JUnit的帮助下，为该方法编写测试非常容易。示例测试如下所示。注意，我们还编辑了main方法，以便它调用“testSwap”而不是“testFindSmallest”或“testSort”。

```java
public class TestSort {
    ...    

    /** Test the Sort.swap method. */
    public static void testSwap() {
        String[] input = {"i", "have", "an", "egg"};
        int a = 0;
        int b = 2;
        String[] expected = {"an", "have", "i", "egg"};

        Sort.swap(input, a, b);
        org.junit.Assert.assertArrayEquals(expected, input);
    }

    public static void main(String[] args) {
        testSwap();
    }
}
```

Running this test on our buggy `swap` yields an error, as we'd expect.

```sh
Exception in thread "main" arrays first differed in element [2]; expected:<[i]> but was:<[an]>
    at TestSort.testSwap(TestSort.java:36)
```

值得一提的是，我们只调用“`testSwap`”而不调用“`testSort`”非常重要。例如，如果我们的“main”方法如下所示，那么一旦“`testSort`”失败，整个“main”将立即终止执行，并且“`testSwap`”将永远不会运行：

```java
public static void main(String[] args) {
    testSort();
    testFindSmallest();
    testSwap();
}
```

**在本章末尾，我们将学习一种更优雅的方法来处理多个测试，这将避免需要手动指定要运行的测试。**

Now that we have a failing test, we can use it to help us debug. One way to do this is to set a breakpoint inside the `swap` method and use the visual debugging feature in IntelliJ. If you would like more information about and practice on debugging, check out [Lab3](https://sp19.datastructur.es/materials/lab/lab3/lab3). Stepping through the code line-by-line makes it immediately clear what is wrong (see video or try it yourself), and we can fix it by updating our code to include a temporary variable as that the beginning of this section:现在我们有一个失败的测试，我们可以使用它来帮助我们调试。**一种方法是在“`swap`”方法中设置断点，并使用IntelliJ中的可视化调试功能**。如果您想了解更多关于调试的信息和实践，**请查看[Lab3](https://sp19.datastructur.es/materials/lab/lab3/lab3)**. 一行一行地遍历代码，可以立即明确错误所在（请看视频或自己尝试），我们可以通过更新代码以包含本节开头的临时变量来解决问题：

```java
public static void swap(String[] x, int a, int b) {
    String temp = x[a];
    x[a] = x[b];
    x[b] = temp;
}
```

Rerunning the test, we see that it now passes.

## Revising findSmallest

Now that we have multiple pieces of our method done, we can start trying to connect them up together to create a `Sort` method.

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
       // find the smallest item
       // move it to the front
       // selection sort the rest (using recursion?)
}
```

It's clear how to use our `findSmallest` and `swap` methods, but when we do so, we immediately realize there is a bit of a mismatch: `findSmallest` returns a `String`, and `swap` expects two indices.

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
       // find the smallest item
       String smallest = findSmallest(x);

       // move it to the front
       swap(x, 0, smallest);

       // selection sort the rest (using recursion?)
}
```

In other words, what `findSmallest` should have been returning is the index of the smallest String, not the String itself. Making silly errors like this is normal and really easy to do, so don't sweat it if you find yourself doing something similar. **==Iterating on a design is part of the process of writing code.==**换句话说，**“`findSmallest`”应该返回的是最小字符串的索引，而不是字符串本身。**犯这种愚蠢的错误很正常, 而且很容易, 所以如果你发现自己在做类似的事情, 不要担心. 迭代设计是编写代码过程的一部分。

幸运的是，这种新设计很容易改变。我们只需调整“`findSmallest`”以返回“`int`”，如下所示：

```java
public static int findSmallest(String[] x) {
    int smallestIndex = 0;
    for (int i = 0; i < x.length; i += 1) {
        int cmp = x[i].compareTo(x[smallestIndex]);
        if (cmp < 0) {
            smallestIndex = i;
        }
    }
    return smallestIndex;
}
```

由于这是一个非常重要的更改，我们还应该更新“`testFindSmallest`”，并确保“`findSmallet`”仍然有效。

```java
public static void testFindSmallest() {
    String[] input = {"i", "have", "an", "egg"};
    int expected = 2;

    int actual = Sort.findSmallest(input);
    org.junit.Assert.assertEquals(expected, actual);        

    String[] input2 = {"there", "are", "many", "pigs"};
    int expected2 = 1;

    int actual2 = Sort.findSmallest(input);
    org.junit.Assert.assertEquals(expected2, actual2);
}
```

After modifying `TestSort` so that this test is run, and running `TestSort.main`, we see that our code passes the tests. Now, revising sort, we can fill in the first two steps of our sorting algorithm.	**在修改“`TestSort`”以运行此测试并运行“`TestSort.main`”之后，我们看到代码通过了测试。现在，修改排序，我们可以填写排序算法的前两个步骤.**

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   // find the smallest item
   // move it to the front
   // selection sort the rest (using recursion?)
   int smallestIndex = findSmallest(x);
   swap(x, 0, smallestIndex);
}
```

剩下的就是以某种方式对剩余的项目进行选择排序，也许可以使用递归。我们将在下一节讨论这个问题。

回顾我们所取得的成就, 值得注意的是, 我们是如何首先创建测试的, 并在我们尝试使用实际方法之前使用这些测试来建立对实际方法有效的信心. 这是一个非常重要的想法, 如果你决定采纳它, 它会很好地为你服务.

## Recursive Helper Methods

To begin this section, consider how you might make the recursive call needed to complete `sort`:

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   int smallestIndex = findSmallest(x);
   swap(x, 0, smallestIndex);
   // recursive call??
}
```

对于那些习惯了Python这样的语言的人来说，尝试使用切片表示法可能会很有吸引力，例如。

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   int smallestIndex = findSmallest(x);
   swap(x, 0, smallestIndex);
   sort(x[1:])
}
```

然而，**Java中没有对子数组的引用，即我们不能只传递数组中下一个项的地址。**

This problem of needing to consider only a subset of a larger array is very common. ==**A typical solution is to create a private helper method that has an additional parameter (or parameters) that delineate which part of the array to consider.**== For example, we might write a private helper method also called `sort` that consider only the items starting with item 	`start`这种只需要考虑较大阵列的子集的问题非常常见. **典型的解决方案是创建一个私有帮助器方法, 该方法具有一个或多个额外的参数, 这些参数描述了要考虑的数组的哪个部分.** 例如, 我们可以编写一个名为“`sort`”的私有助手方法, 它只考虑以`start`开头的项.

```java
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
    // TODO
}
```

与我们的公共排序方法不同，现在使用递归比较简单，因为我们有了额外的参数“`start`”，如下所示。我们将在下一节测试此方法。

```java
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { // 私有的private方法
   int smallestIndex = findSmallest(x);
   swap(x, start, smallestIndex);
   sort(x, start + 1);
}
```

现在我们有了一个helper方法，我们需要设置正确的原始调用。如果我们将开始值设置为0，我们将有效地对整个数组进行排序。

```java
/** Sorts strings destructively. */
public static void sort(String[] x) { 
   sort(x, 0); // 参数不同(数量), 签名不同, 可以重载
}
```

当试图在非固有递归的数据结构(例如数组)上使用递归时, 这种方法非常常见.

## Debugging and Completing Sort

运行“`testSort`”方法时，我们立即遇到一个问题：

```sh
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
    at Sort.swap(Sort.java:16)
```

Using the Java debugger(调试器), we see that the problem is that somehow `start` is reaching the value 4. Stepping through the code carefully (see video above), we find that the issue is that we forgot to include a base case in our recursive `sort` method. Fixing this is straightforward:

```java
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
   if (start == x.length) {
       return;
   }
   int smallestIndex = findSmallest(x);
   swap(x, start, smallestIndex);
   sort(x, start + 1);
}
```

Rerunning this test again, we get another error:

```sh
Exception in thread "main" arrays first differed at element [0]; 
   expected<[an]> bit was:<[have]>
```

同样，通过明智地使用IntelliJ调试器（请参见视频），我们可以识别结果与预期不符的代码行。值得注意的是，**我调试代码的抽象级别比您可能拥有的抽象级别更高，这是通过使用“`Step Over`”而不是“`Step Into`”实现的。** **正如在实验室3中所讨论的，通过允许您将整个函数调用的结果与预期进行比较，在更高抽象级别上进行调试可以节省大量时间和精力。**

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230120232832401.png" alt="image-20230120232832401" style="zoom: 50%;" />

> ==**可以给断点设置条件**==

Specifically, we find that when sorting the last 3 (out of 4) items, the `findSmallest` method is giving as the 0th item (`"an"`) rather than the 3rd item (`"egg"`) when called on the input `{"an", "have", "i", "egg"}`. Looking carefully at the definition of `findSmallest`, this behavior is not a surprise, since `findSmallest` looks at the entire array, not just the items starting from position `start`. This sort of design flaw is very common, **and writing tests and using the debugger is a great way to go about fixing them.**

To fix our code, we revise `findSmallest` so that it takes a second parameter `start`, i.e. `findSmallest(String[] x, int start)`. In this way, we ensure that we're finding the smallest item only out of the last however many are still unsorted. The revision is as shown below:

```java
public static int findSmallest(String[] x, int start) {
    int smallestIndex = start;
    for (int i = start; i < x.length; i += 1) {
        int cmp = x[i].compareTo(x[smallestIndex]);
        if (cmp < 0) {
            smallestIndex = i;
        }
    }
    return smallestIndex;
}
```

Given that we've made a significant change to one of our building blocks, i.e. `findSmallest`, we should ensure that our changes are correct.

We first modify `testFindSmallest` so that it uses our new parameter, as shown below:

```java
public static void testFindSmallest() {
    String[] input = {"i", "have", "an", "egg"};
    int expected = 2;

    int actual = Sort.findSmallest(input, 0);
    org.junit.Assert.assertEquals(expected, actual);        

    String[] input2 = {"there", "are", "many", "pigs"};
    int expected2 = 2;

    int actual2 = Sort.findSmallest(input2, 2);
    org.junit.Assert.assertEquals(expected2, actual2);
}
```

We then modify `TestSort.main` so that it runs `testFindSmallest`. This test passes, strongly suggesting that our revisions to `findSmallest` were correct.

We next modify `Sort.sort` so that it uses the new `start` parameter in `findSmallest`:

```java
/** Sorts strings destructively starting from item start. */
private static void sort(String[] x, int start) { 
   if (start == x.length) {
       return;
   }
   int smallestIndex = findSmallest(x, start);
   swap(x, start, smallestIndex);
   sort(x, start + 1);
}
```

We then modify `TestSort` so that it runs `TestSort.sort` and voila, the method works. We are done! You have now seen the "new way" from the beginning of this lecture, which we'll reflect on for the remainder of this chapter.

## Reflections on the Development Process 关于发展过程的思考

在编写和调试程序时，您经常会发现自己在不同的上下文之间切换。试图一次在大脑中容纳太多东西，最坏的情况下会导致灾难，最好的情况下则会导致进展缓慢。

拥有一套自动化测试有助于减轻这种认知负荷。例如，当我们正在编写“`sort`”时，发现“`findSmallest`”中有一个错误。我们能够切换上下文以考虑“`findSmallest`”，并使用“`testFindSmallest`”方法确定它是正确的，然后切换回“sort”。这与一种更天真的方法形成鲜明对比，在这种"天真"的方法中，您只需反复调用“`sort`”，并试图找出整个算法的行为是否表明“`findSmallest`”方法是正确的。

作为一个类比，你可以通过进入飞机，起飞，跳出来，拉动撕裂线，看看降落伞是否出来，来测试降落伞的撕裂线是否有效。然而，你也可以把它放在地上，看看会发生什么。所以，也没有必要使用“sort”来尝试“findSmallest”。

正如本章前面提到的，测试还可以让您对程序的基本部分产生信心，这样，如果出现问题，您就可以更好地了解从哪里开始查找。

最后，测试使重构代码更容易。假设您决定重写“`findSmallest`”，使其更快或更可读。我们可以通过进行所需的更改并查看测试是否仍然有效来安全地做到这一点。

## Better JUnit

首先，让我们回顾一下我们今天看到的新语法，即“`org.junit.Assert.assertEquals`”。此方法（名称很长）测试“`expected`”和“`actual`”是否相等，如果不相等，则使用详细的错误消息终止程序。

JUnit除了“`assertEquals`”之外还有很多这样的方法，例如“`assertFalse`”、“`assertNotNull`”、“`fail`”等等，它们可以在官方[JUnit文档](http://junit.org/junit4/javadoc/4.12/org/junit/Assert.html)中找到. JUnit还有许多其他复杂的特性，我们不会在61B中描述或教授，尽管您可以自由使用它们。

虽然JUnit确实改进了一些东西，但我们以前的测试代码在几个方面都有点笨拙。在本节的剩余部分中，我们将讨论您可以进行的两个主要增强，以使代码更干净、更易于使用。从语法角度来看，这些增强功能看起来非常神秘，所以只需复制我们目前正在做的，我们将在后面的章节中解释其中的一些（但不是全部）。

==**The first enhancement** is to use what is known as a "**test annotation(测试注释)**"==. To do this, we:

- Precede each method with `@org.junit.Test` (no semi-colon).在每个方法前面加上`@org.junit.Test `（无分号）。
- Change each test method to be non-static.将每个测试方法更改为非静态。
- Remove our `main` method from the `TestSort` class. 从“`TestSort`”类中删除我们的“`main`”方法。

Once we've done these three things, if we re-run our code in JUnit using the Run->Run command, all of the tests execute without having to be manually invoked. This annotation based approach has several advantages:

- No need to manually invoke tests.无需手动调用测试。
- All tests are run, not just the ones we specify.所有测试都在运行，而不仅仅是我们指定的测试。
- If one test fails, the others still run.如果一个测试失败，其他测试仍在运行。
- A count of how many tests were run and how many passed is provided.提供了运行的测试数和通过的测试数。
- The error messages on a test failure are much nicer looking.测试失败的错误消息看起来更漂亮。
- If all tests pass, we get a nice message and a green bar appears, rather than simply getting no output.如果所有测试都通过了，我们会收到一条漂亮的消息，并出现一条绿色的条，而不是简单地没有输出。

==**The second enhancement will let us use shorter names for some of the very lengthy method names**==, as well as the annotation(注释) name. Specifically, we'll use what is known as an "==import statement==".

**We first add the import statement `import org.junit.Test;` to the top of our file. After doing this, we can replace all instances of `@org.junit.Test` with simply `@Test`.**

We then add our second import statement `import static org.junit.Assert.*`. After doing this, anywhere we can omit anywhere we had `org.junit.Assert.`. For example, we can replace `org.junit.Assert.assertEquals(expected2, actual2);` with simply `assertEquals(expected2, actual2);`

We will explain exactly why import statements are in a later lecture. For now, just use and enjoy.

## Testing Philosophy

#### Correctness Tool #1: Autograder

**However, autograders don't exist in the real world and relying on autograders can build bad habits**. One's workflow is hindered by sporadically uploading your code and waiting for the autograder to run. *Autograder Driven Development* is an extreme version of this in which students write all their code, fix their compiler errors, and then submit to the autograder. After getting back errors, students may try to make some changes, sprinkle in print statements, and submit again. And repeat. Ultimately, you are not in control of either your workflow or your code if you rely on an autograder.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230121000547167.png" alt="image-20230121000547167" style="zoom: 33%;" />

#### Correctness Tool #2: JUnit Tests

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230121000647376.png" alt="image-20230121000647376" style="zoom: 33%;" />

> 优点 : 
>
> + 对基础单元都充满信心
>
> 缺点:
>
> + 很难写出建立在其他对象之上的单元测试

***Test-Driven Development (TDD)***

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230121000842041.png" alt="image-20230121000842041" style="zoom:33%;" />

TDD is a development process in which we write tests for code before writing the code itself. The steps are as follows:

1. Identify a new feature.识别新功能。
2. Write a unit test for that feature.为该功能编写单元测试。
3. Run the test. It should fail.运行测试。它应该会失败。
4. Write code that passes the test. Yay!编写通过测试的代码。耶！
5. Optional: refactor code to make it faster, cleaner, etc. Except now we have a reference to tests that should pass.可选：重构代码以使其更快、更干净等。但现在我们有一个应该通过的测试的引用。

Test-Driven Development is not required in this class and may not be your style but unit testing in general is most definitely a good idea.测试驱动开发在这个类中不是必需的，也可能不是您的风格，但一般来说，单元测试绝对是一个好主意。

#### Correctness Tool #3: Integration Testing 综合测试

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230121000957578.png" alt="image-20230121000957578" style="zoom:33%;" />

> 优点:
>
> + 单元测试不足以确保模块正确交互或系统按预期工作。
>
> 缺点:
>
> + 手动操作可能会很乏味。
> + 自动化可能具有挑战性。
> + 在最高抽象级别的测试可能会漏掉细微或罕见的错误

As a summary, you should **definitely write tests but only when they might be useful!** Taking inspiration from TDD, writing your tests before writing code can also be very helpful in some cases.

## What's next?

- [Project 1b](https://sp19.datastructur.es/materials/proj/proj1b/proj1b)