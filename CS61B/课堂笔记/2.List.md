# Lists

在项目0中，我们使用数组跟踪空间中N个对象的位置。有一件事我们无法轻易做到，那就是在模拟开始后更改对象的数量。这是因为数组在Java中具有固定的大小，永远不会改变。

An alternate approach would have been to use a list type. You've no doubt used a list data structure at some point in the past. For example, in Python:

```python
L = [3, 5, 6]
L.append(7)
```

**While Java does have a built-in List type, we're going to eschew using it for now. In this chapter, we'll build our own list from scratch, along the way learning some key features of Java.**虽然Java有一个内置的List类型，但我们现在将避免使用它。在本章中，我们将从头开始构建自己的List，同时学习Java的一些关键特性。

## The Mystery of the Walrus

To begin our journey, we will first ponder(沉思, 琢磨) the profound Mystery of the Walrus.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230122162806827.png" alt="image-20230122162806827" style="zoom: 35%;" />

While subtle(微妙的, 不易察觉的), the key ideas that underlie the Mystery of the Walrus will be incredibly important to the efficiency of the data structures that we'll implement in this course, and a deep understanding of this problem will also lead to safer, more reliable code.**虽然微妙(微妙的, 不易察觉的), ==海象之谜背后的关键思想对于我们将在本课程中实现的数据结构的效率将非常重要，对这个问题的深入理解也将导致更安全、更可靠的代码==。**

## Bits

计算机中的所有信息都以`01序列`存储在*内存*中。一些示例：

- 72 is often stored as 01001000
- 205.75 is often stored as 01000011 01001101 11000000 00000000
- The letter H is often stored as 01001000 (same as 72)
- The true value is often stored as 00000001

在本课程中，我们不会花太多时间讨论具体的二进制表示，例如为什么205.75被存储为32位以上的看似随机的字符串。理解具体表示是[CS61C](http://www-inst.eecs.berkeley.edu/~cs61c/)的主题，61B的后续课程。

Though we won't learn the language of binary, it's good to know that this is what is going on under the hood.

一个有趣的观察是，72和H都存储为01001000。这就提出了一个问题：一段Java代码如何知道如何解释01001000？

The answer is through types! For example, consider the code below:答案是通过类型！例如，考虑以下代码：

```java
char c = 'H';
int x = c;
System.out.println(c);
System.out.println(x);
```

If we run this code, we get:

```java
H
72
```

In this case, both the x and c variables contain the same bits (well, almost...), but the Java interpreter treats them differently when printed.

**在Java中，有8种基本类型：byte、short、int、long、float、double、boolean和char。每一个都有不同的属性，我们将在整个课程中讨论(除了short和float，您可能永远不会使用它们)。**

## Declaring a Variable (Simplified)

```java
int x;
double y;
```

We'd end up with boxes of size 32 and 64 respectively, as shown in the figure below:

![x_and_y_empty_bitwise](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/x_and_y_empty_bitwise.png)

**==The Java language provides no way for you to know the location of the box==**, e.g. you can't somehow find out that x is in position 352. In other words, **the exact memory address is below the level of abstraction accessible to us in Java. This is unlike languages like C where you can ask the language for the exact address of a piece of data. For this reason, I have omitted the addresses from the figure above.**

Java的这一特性是一种折衷(折衷)! 对程序员隐藏内存位置会减少控制，从而阻止您执行某些[类型的优化](http://www.informit.com/articles/article.aspx?p=2246428&seqNum=5). 然而，它也避免了[一大类非常棘手的编程错误](http://www.informit.com/articles/article.aspx?p=2246428&seqNum=1). 在成本非常低的现代计算时代，这种权衡通常是值得的。正如明智的唐纳德·克努思（Donald Knuth）曾经说过的：“我们应该忘记小效率，比如97%的时间：过早的优化是万恶之源”。

作为类比，你不能直接控制你的心跳。虽然这限制了您针对某些情况进行优化的能力，但也避免了发生愚蠢错误的可能性，例如意外关闭。

声明变量时，Java不会向保留框中写入任何内容。换句话说，没有默认值。因此，Java编译器会阻止您使用变量，直到使用“=”运算符在框中填充了位。出于这个原因，我避免在上图框中显示任何位。

When you assign values to a memory box, it is filled with the bits you specify. For example, if we execute the lines:

```java
x = -1431195969;
y = 567213.112;
```

Then the memory boxes from above are filled as shown below, in what I call **box notation**.

![x_and_y_empty_filled.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/x_and_y_empty_filled.png)

更详细学习请参考CS61C

### Simplified Box Notation

While the box notation we used in the previous section is great for understanding approximately what's going on under the hood, it's not useful for practical purposes since we don't know how to interpret the binary bits.

Thus, instead of writing memory box contents in binary, we'll write them in human readable symbols. We will do this throughout the rest of the course. For example, after executing:

```java
int x;
double y;
x = -1431195969;
y = 567213.112;
```

We can represent the program environment using what I call **simplified box notation**, shown below:

![x_and_y_simplified_box_notation.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/x_and_y_simplified_box_notation.png)

## ==The Golden Rule of Equals (GRoE)==

Now armed with simplified box notation, we can finally start to resolve the Mystery of the Walrus.

It turns out our Mystery has a simple solution: ==When you write `y = x`, you are telling the Java interpreter to copy the bits from x into y==. This Golden Rule of Equals (GRoE) is the root of all truth when it comes to understanding our Walrus Mystery.

```java
int x = 5;
int y;
y = x;
x = 2;
System.out.println("x is: " + x);
System.out.println("y is: " + y);
```

This simple idea of copying the bits is true for ANY assignment using `=` in Java. To see this in action, click [this link](http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+{ +++public+static+void+main(String[]+args)+{ ++++++int+x+%3D+5%3B ++++++int+y%3B ++++++y+%3D+x%3B ++++++x+%3D+2%3B ++++++System.out.println("x+is%3A+"+%2B+x)%3B ++++++System.out.println("y+is%3A+"+%2B+y)%3B++++++ +++} }&mode=display&curInstr=0).

## Reference Types

Above, we said that there are 8 primitive types: byte, short, int, long, float, double, boolean, char. ==**Everything else, including arrays, is not a primitive type but rather a `reference type`.**==

### Object Instantiation 对象实例化

When we *instantiate* an Object using `new` (e.g. Dog, Walrus, Planet), **Java first allocates a box for each instance variable of the class, and fills them with a default value. The constructor then usually (but not always) fills every box with some other value.**

For example, if our Walrus class is:

```java
public static class Walrus {
    public int weight;
    public double tuskSize;

    public Walrus(int w, double ts) {
          weight = w;
          tuskSize = ts;
    }
}
```

And we create a Walrus using `new Walrus(1000, 8.3);`, then we end up with a Walrus consisting of two boxes of 32 and 64 bits respectively:

![anonymous_walrus.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/anonymous_walrus.png)

在Java编程语言的实际实现中，实际上任何对象都会有一些额外的开销，因此Walrus需要96位以上。然而，出于我们的目的，我们将忽略这些开销，因为我们永远不会与它直接交互。

The Walrus we've created is anonymous, in the sense that it has been created, but it is not stored in any variable. Let's now turn to variables that store objects.我们创建的海象是匿名的(`new Walrus(1000, 8.3)`)，因为它已经被创建，但它没有存储在任何变量中。现在让我们转向存储对象的变量。

### Reference Variable Declaration 引用变量声明

==**When we *declare* a variable of any reference type (Walrus, Dog, Planet, array, etc.), Java allocates a box of 64 bits, no matter what type of object.**==

乍一看，这可能会导致海象悖论。上一节中的海象需要64位以上的存储。此外，无论是哪种类型的对象，我们只能得到64位来存储它，这可能看起来很奇怪。

However, this problem is easily resolved with the following piece of information: **==the 64 bit box contains not the data about the walrus, but instead the address of the Walrus in memory==**.然而，这个问题很容易通过以下信息得到解决：64位框中不包含海象的数据，而是内存中海象的地址。

As an example, suppose we call:

```java
Walrus someWalrus;
someWalrus = new Walrus(1000, 8.3);
```

The first line creates a box of 64 bits. The second line creates a new Walrus, and the address is returned by the `new` operator. These bits are then copied into the `someWalrus` box according to the GRoE.

If we imagine our Walrus weight is stored starting at bit `5051956592385990207` of memory, and tuskSize starts at bit `5051956592385990239`, we might store `5051956592385990207` in the Walrus variable. In binary, `5051956592385990207` is represented by the 64 bits `0100011000011100001001111100000100011101110111000001111000111111`, giving us in box notation:

![someWalrus_bit_notation.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/someWalrus_bit_notation.png)

**We can also assign the special value `null` to a reference variable, corresponding to all zeros.**

![someWalrus_bit_notation_null.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/someWalrus_bit_notation_null.png)

### Box and Pointer Notation

Just as before, it's hard to interpret a bunch of bits inside a reference variable, so we'll create a simplified box notation for reference variable as follows:

- **If an address is all zeros, we will represent it with null.**
- A non-zero address will be represented by an **arrow** pointing at an object instantiation.

This is also sometimes called "box and pointer" notation.

For the examples from the previous section, we'd have:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/someWalrus_simplified_bit_notation.png" alt="someWalrus_simplified_bit_notation.png" style="zoom:67%;" />

![someWalrus_simplified_bit_notation_null.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/someWalrus_simplified_bit_notation_null.png)

### Resolving the Mystery of the Walrus

We're now finally ready to resolve, fully and completely, the Mystery of the Walrus.

```java
Walrus a = new Walrus(1000, 8.3);
Walrus b;
b = a;
```

After the first line is executed, we have:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/mystery_of_the_walrus_resolved_step1.png" alt="mystery_of_the_walrus_resolved_step1.png" style="zoom:50%;" />

After the second line is executed, we have:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/mystery_of_the_walrus_resolved_step2.png" alt="mystery_of_the_walrus_resolved_step2.png" style="zoom: 50%;" />

Note that above, b is undefined, not null.

According to the GRoE, the final line simply copies the bits in the `a` box into the `b` box. Or in terms of our visual metaphor, this means that b will copy exactly the arrow in a and now show an arrow pointing at the same object.

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/mystery_of_the_walrus_resolved_step3.png" alt="mystery_of_the_walrus_resolved_step3.png" style="zoom:50%;" />

And that's it. There's no more complexity than this.

## Parameter Passing 参数传递 

When you pass parameters to a function, you are also simply copying the bits. ==**In other words, the GRoE also applies to parameter passing.**== ==**Copying the bits is usually called "pass by value". In Java, we always pass by value.**==

For example, consider the function below:

```java
public static double average(double a, double b) {
    return (a + b) / 2;
}
```

Suppose we invoke this function as shown below:

```java
public static void main(String[] args) {
    double x = 5.5;
    double y = 10.5;
    double avg = average(x, y);
}
```

执行此函数的前两行后，主方法将有两个标记为“x”和“y”的框，其中包含以下值：

![main_x_y.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/main_x_y.png)

When the function is invoked, the `average` function has its **own** scope with two new boxes labeled as `a` and `b`, and the bits are simply *copied* in. This copying of bits is what we refer to when we say "pass by value".当调用该函数时，“average”函数有**自己的**作用域，带有两个标记为“a”和“b”的新框，这些位被简单地“复制”进去。这种位的复制就是我们所说的“传递值”。

![average_a_b.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig21/average_a_b.png)

If the `average` function were to change `a`, then `x` in main would be unchanged, since the GRoE tells us that we'd simply be filling in the box labeled `a` with new bits.

### Test Your Understanding

**Exercise 2.1.1**: Suppose we have the code below:

```java
public class PassByValueFigure {
    public static void main(String[] args) {
           Walrus walrus = new Walrus(3500, 10.5);
           int x = 9;

           doStuff(walrus, x);
           System.out.println(walrus);
           System.out.println(x);
    }

    public static void doStuff(Walrus W, int x) {
           W.weight = W.weight - 100;
           x = x - 5;
    }
}
```

Does the call to `doStuff` have an effect on walrus and/or x? Hint: We only need to know the GRoE to solve this problem.

> answer : `W.weight` changed `x` not change

## Instantiation of Arrays Array的实例化

As mentioned above, variables that store arrays are reference variables just like any other. As an example, consider the declarations below:如上所述，**==存储数组的变量和其他变量一样都是引用变量==**。例如，考虑以下声明：

```java
int[] x;
Planet[] planets;
```

**Both of these declarations create memory boxes of 64 bits.** `x` can only hold the address of an `int` array, and `planets` can only hold the address of a `Planet` array.

Instantiating an array is very similar to instantiating an object. For example, if we create an integer array of size 5 as shown below:

```java
x = new int[]{0, 1, 2, 95, 4};
```

Then the `new` keyword creates 5 boxes of 32 bits each and returns the address of the overall object for assignment to x.

Objects can be lost if you lose the bits corresponding to the address. For example if the only copy of the address of a particular Walrus is stored in `x`, then `x = null` will cause you to permanently lose this Walrus. This isn't necessarily a bad thing, since you'll often decide you're done with an object, and thus **==it's safe to simply throw away the reference. We'll see this when we build lists later in this chapter.==**

> 总结 : `int[]`是声明, 只是分配了一个64位的box, new int[]是分配内容, `=`是用pointer连接在一起

### The Law of the Broken Futon

你可能会问自己，为什么我们花了这么多时间和空间来处理看似琐碎的事情。如果您以前有Java经验，这可能尤其正确。原因是，学生很容易对这个问题有一个半吊子的理解，允许他们编写代码，但没有真正理解发生了什么。

虽然这在短期内可能很好，但从长远来看，在没有充分理解的情况下解决问题可能会让你在未来失败。有一篇博客文章是关于这个所谓的[破蒲团定律](https://mathwithbaddrawings.com/2015/04/08/the-math-ceiling-wheres-your-cognitive-breaking-point/)你可能会觉得有趣。

> 要理解真正发生了什么, 理解每一步

**==不仅要能回答问题, 而且要理解问题==**

## IntLists

既然我们已经真正了解了海象之谜，我们就可以建立自己的列表类了。

**It turns out that a very basic list is trivial(微不足道) to implement, as shown below:**

```java
public class IntList {
    public int first;
    public IntList rest;        

    public IntList(int f, IntList r) {
        first = f;
        rest = r;
    }
}
```

你可能还记得61a中的类似内容，称为“Linked List”。

Such a list is ugly to use. For example, if we want to make a list of the numbers 5, 10, and 15, we can either do:这样的列表使用起来很难看。例如，如果我们想列出数字5、10和15，我们可以这样做：

```java
IntList L = new IntList(5, null);
L.rest = new IntList(10, null);
L.rest.rest = new IntList(15, null);
```

Alternately, we could build our list backwards, yielding slightly nicer but harder to understand code:或者，我们可以向后构建列表，生成稍微更好但更难理解的代码：

```java
IntList L = new IntList(15, null);
L = new IntList(10, L);
L = new IntList(5, L);
```

While you could in principle use the IntList to store any list of integers, the resulting code would be rather ugly and prone to errors. We'll adopt the usual object oriented programming strategy of adding helper methods to our class to perform basic tasks.虽然原则上可以使用IntList来存储任何整数列表，但生成的代码将相当难看，并且容易出错。我们将采用通常的面向对象编程策略，向类中添加辅助方法来执行基本任务。

### size and iterativeSize 大小和迭代大小

We'd like to add a method `size` to the `IntList` class so that if you call `L.size()`, you get back the number of items in `L`.

Consider writing a `size` and `iterativeSize` method before reading the rest of this chapter. **`size` should use recursion, and `iterativeSize` should not.** You'll probably learn more by trying on your own before seeing how I do it. The two videos provide a live demonstration of how one might implement these methods.

My `size` method is as shown below:

```java
/** Return the size of the list using... recursion! */
public int size() {
    if (rest == null) {
        return 1;
    }
    return 1 + this.rest.size();
}
```

The key thing to remember about recursive code is that you need a base case. In this situation, the most reasonable base case is that rest is `null`, which results in a size 1 list.

**Exercise: You might wonder why we don't do something like `if (this == null) return 0;`. Why wouldn't this work?**

**Answer: Think about what happens when you call size. You are calling it on an object, for example L.size(). If L were null, then you would get a NullPointer error!**

My `iterativeSize` method is as shown below. I recommend that when you write iterative data structure code that you use the name `p` to remind yourself that the variable is holding a pointer. You need that pointer because ==you can't reassign "this" in Java==. The followups in [this Stack Overflow Post](https://stackoverflow.com/questions/23021377/reassign-this-in-java-class) offer a brief explanation as to why.

```java
/** Return the size of the list using no recursion! */
public int iterativeSize() {
    IntList p = this;
    int totalSize = 0;
    while (p != null) {
        totalSize += 1;
        p = p.rest;
    }
    return totalSize;
}
```

### get

While the `size` method lets us get the size of a list, we have no easy way of getting the ith element of the list.

Exercise: Write a method `get(int i)` that returns the ith item of the list. For example, if `L` is 5 -> 10 -> 15, then `L.get(0)` should return 5, `L.get(1)` should return 10, and `L.get(2)` should return 15. It doesn't matter how your code behaves for invalid `i`, either too big or too small.

For a solution, see the lecture video above or the lecture Code repository.

Note that the method we've written takes linear time! That is, if you have a list that is 1,000,000 items long, then getting the last item is going to take much longer than it would if we had a small list. We'll see an alternate way to implement a list that will avoid this problem in a future lecture.

### What Next

- [Lab setup](http://sp19.datastructur.es/materials/lab/lab2setup/lab2setup)
- [Lab 2](http://sp19.datastructur.es/materials/lab/lab2/lab2)







# SLLists

In Chapter 2.1, we built the `IntList` class, a list data structure that can technically do all the things a list can do. However, in practice, the `IntList` suffers from the fact that it is fairly awkward to use, resulting in code that is hard to read and maintain.在第2.1章中，我们构建了“IntList”类，这是一种列表数据结构，在技术上可以完成列表所能做的所有事情。然而，在实践中，“IntList“的缺点是使用起来相当困难，导致代码难以读取和维护。

Fundamentally, ==the issue is that the `IntList` is what I call a **naked recursive** data structure==. In order to use an `IntList` correctly, the programmer must understand and utilize recursion even for simple list related tasks. This limits its usefulness to novice programmers, and potentially introduces a whole new class of tricky errors that programmers might run into, depending on what sort of helper methods are provided by the `IntList` class.

受“`IntList`”经验的启发，我们现在将构建一个新的类“`SLList`”，它与程序员在现代语言中使用的列表实现非常相似。我们将通过迭代添加一系列改进来实现

## Improvement #1: Rebranding

Our `IntList` class from last time was as follows, with helper methods omitted:

```java
public class IntList {
    public int first;
    public IntList rest;

    public IntList(int f, IntList r) {
        first = f;
        rest = r;
    }
...
```

Our first step will be to simply rename everything and throw away the helper methods. This probably doesn't seem like progress, but trust me, I'm a professional.

```java
public class IntNode {
    public int item; // 内容, 是int型的
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

## Improvement #2: Bureaucracy

Knowing that `IntNodes` are hard to work with, we're going to create a separate class called `SLList` that the user will interact with. The basic class is simply:

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }
}
```

Already, we can get a vague sense of why a `SLList` is better. Compare the creation of an `IntList` of one item to the creation of a `SLList` of one item.我们已经可以模糊地理解为什么“`SLList`”更好。将创建一个项的“`IntList`”与创建一个项目的“`SLList`”进行比较。

```java
IntList L1 = new IntList(5, null);
SLList L2  = new SLList(5);
```

The `SLList` hides the detail that there exists a null link from the user. The `SLList` class isn't very useful yet, so let's add an `addFirst` and `getFirst` method as simple warmup methods. Consider trying to write them yourself before reading on.

## addFirst and getFirst

`addFirst` is relatively straightforward if you understood chapter 2.1. With `IntLists`, we added to the front with the line of code `L = new IntList(5, L)`. Thus, we end up with:

```java
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }

    /** Adds an item to the front of the list. */
    public void addFirst(int x) {
        first = new IntNode(x, first);
    }
}
```

`getFirst` is even easier. We simply return `first.item`:

```java
/** Retrieves the front item from the list. */
public int getFirst() {
    return first.item;
}
```

The resulting `SLList` class is much easier to use. Compare:

```java
SLList L = new SLList(15);
L.addFirst(10);
L.addFirst(5);
int x = L.getFirst();
```

to the `IntList` equivalent:

```java
IntList L = new IntList(15, null);
L = new IntList(10, L);
L = new IntList(5, L);
int x = L.first;
```

直观地比较这两个数据结构，我们得到了：（顶部是“`IntList`”版本，下面是“`SLList`”版本）

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/IntList_vs_SLList.png" alt="IntList_vs_SLList.png" style="zoom: 67%;" />

Essentially, ==the `SLList` class acts as a middleman between the list user and the naked recursive data structure.== As suggested above in the `IntList` version, there is a potentially undesireable possibility for the `IntList` user to have variables that point to the middle of the `IntList`. As Ovid said: [Mortals cannot look upon a god without dying](https://en.wikipedia.org/wiki/Semele), so perhaps it is best that the `SLList` is there to act as our intermediary.

**Exercise 2.2.1**: The curious reader might object and say that the `IntList` would be just as easy to use if we simply wrote an `addFirst` method. Try to write an `addFirst` method to the `IntList` class. You'll find that the resulting method is tricky as well as inefficient.	好奇的读者可能会反对并说，如果我们只编写一个“addFirst”方法，那么“IntList”也同样容易使用。尝试将“addFirst”方法写入“IntList”类。您会发现，生成的方法既复杂又低效。

## Improvement #3: Public vs. Private

Unfortunately, our `SLList` can be bypassed and the raw power of our naked data structure (with all its dangers) can be accessed. A programmer can easily modify the list directly, without going through the kid-tested, mother-approved `addFirst` method, for example:

```java
SLList L = new SLList(15);
L.addFirst(10);
L.first.next.next = L.first.next;
```

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/bad_SLList.png" alt="bad_SLList.png" style="zoom:67%;" />

This results in a malformed list with an infinite loop. To deal with this problem, we can modify the `SLList` class so that the `first` variable is declared with the `private` keyword.

```java
public class SLList {
    private IntNode first;
...
```

Private variables and methods can only be accessed by code inside the same `.java` file, e.g. in this case `SLList.java`. That means that a class like `SLLTroubleMaker` below will fail to compile, yielding a `first has private access in SLList` error.

```java
public class SLLTroubleMaker {
    public static void main(String[] args) {
        SLList L = new SLList(15);
        L.addFirst(10);
        L.first.next.next = L.first.next;
    }
}
```

By contrast, any code inside the `SLList.java` file will be able to access the `first` variable.

It may seem a little silly to restrict access. After all, the only thing that the `private` keyword does is break programs that otherwise compile. ==However, in large software engineering projects, the `private` keyword is an invaluable signal that certain pieces of code should be ignored (**and thus need not be understood**) by the end user. Likewise, the `public` keyword should be thought of as a declaration that a method is available and will work **forever** exactly as it does now.==

作为类比，汽车具有某些“公共”功能，例如油门和刹车踏板。在引擎盖下面，有关于这些操作的“私人”细节。在汽油驱动的汽车中，油门踏板可能控制某种燃料喷射系统，而在电池驱动的汽车上，油门踏板可以调节输送给电机的电池电量。虽然私人细节可能因车而异，但我们希望所有油门踏板都有相同的行为。更改这些将引起用户的极大恐慌，并可能引发可怕的事故。

**==When you create a `public` member (i.e. method or variable), be careful, because you're effectively committing to supporting that member's behavior exactly as it is now, forever.==**

## Improvement #4: ==Nested Classes==

At the moment, we have two `.java` files: `IntNode` and `SLList`. However, the `IntNode` **is really just a supporting character** in the story of `SLList`.

Java provides us with the ability to embed a class declaration inside of another for just this situation. The syntax is straightforward and intuitive:	**==Java为我们提供了将类声明嵌入到另一个类声明中的能力.==**语法简单直观：

```java
public class SLList {
       public class IntNode {
            public int item;
            public IntNode next;
            public IntNode(int i, IntNode n) {
                item = i;
                next = n;
            }
       }

       private IntNode first; 

       public SLList(int x) {
           first = new IntNode(x, null);
       } 
...
```

==**拥有一个嵌套类对代码性能没有任何意义，只是一个保持代码组织的工具!!!!!!!!!!!!!**==有关嵌套类的更多信息，请参见[Oracle官方文档](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html).

If the nested class has no need to use any of the instance methods or variables of `SLList`, you may declare the nested class `static`, as follows. Declaring a nested class as `static` means that methods inside the static class can not access any of the members of the enclosing class. In this case, it means that no method in `IntNode` would be able to access `first`, `addFirst`, or `getFirst`.==**如果嵌套类不需要使用“`SLList`”的任何实例方法或变量，则可以将嵌套类声明为“`static`**”==，如下所示。**==将嵌套类声明为“`static`”意味着静态类内的方法不能访问封闭类的任何成员。==**在这种情况下，这意味着“`IntNode`”中的任何方法都不能访问“`first`”、“`addFirst`”或“`getFirst`”。

> **==不会向外看 \=\=\= static	(现阶段这样记住即可)==**

```java
public class SLList {
       public static class IntNode {
            public int item;
            public IntNode next;
            public IntNode(int i, IntNode n) {
                item = i;
                next = n;
            }
       }

       private IntNode first;
...
```

==**This saves a bit of memory, because each `IntNode` no longer needs to keep track of how to access its enclosing `SLList`**==.这节省了一点内存，因为每个“IntNode”不再需要跟踪如何访问其封闭的“SLList”

Put another way, if you examine the code above, you'll see that the `IntNode` class never uses the `first` variable of `SLList`, nor any of `SLList`'s methods. As a result, we can use the static keyword, which means the `IntNode` class doesn't get a reference to its boss, saving us a small amount of memory.换句话说，如果您检查上面的代码，您会发现“IntNode”类从未使用“SLList”的“first”变量，也不会使用“SLList”的任何方法。因此，我们可以使用static关键字，**这意味着“IntNode”类不会获得对其boss的引用，从而节省了少量内存。**

If this seems a bit technical and hard to follow, try Exercise 2.2.2. A simple rule of thumb is that *if you don't use any instance members of the outer class, make the nested class static*.如果这看起来有点技术性且难以遵循，请尝试练习2.2.2。**==一个简单的经验法则是*如果不使用外部类的任何实例成员，请将嵌套类设置为静态*。==**

**Exercise 2.2.2** Delete the word `static` as few times as possible so that [this program](https://joshhug.gitbooks.io/hug61b/content/chap2/exercises/Government.java) compiles (Refresh the page after clicking the link and making sure the url changed). Make sure to read the comments at the top before doing the exercise.

## addLast() and size()

To motivate our remaining improvements and also demonstrate some common patterns in data structure implementation, we'll add `addLast(int x)` and `size()` methods. You're encouraged to take the [starter code](https://github.com/Berkeley-CS61B/lectureCode/blob/master/lists2/DIY/addLastAndSize/SLList.java) and try it yourself before reading on. I especially encourage you to try to write a recursive implementation of `size`, which will yield an interesting challenge.

I'll implement the `addLast` method iteratively, though you could also do it recursively. The idea is fairly straightforward, we create a pointer variable `p` and have it iterate through the list to the end.	

```java
/** Adds an item to the end of the list. */
public void addLast(int x) {
    IntNode p = first;

    /* Advance p to the end of the list. */
    while (p.next != null) {
        p = p.next;
    }
    p.next = new IntNode(x, null);
}
```

By contrast, I'll implement `size` recursively. This method will be somewhat similar to the `size` method we implemented in section [2.1](https://joshhug.gitbooks.io/hug61b/content/chap2/chap21.html) for `IntList`.

The recursive call for `size` in `IntList` was straightforward: `return 1 + this.rest.size()`. For a `SLList`, this approach does not make sense. A `SLList` has no `rest` variable. **Instead, we'll use a common pattern that is used with middleman classes like `SLList` -- ==we'll create a private helper method that interacts with the underlying naked recursive data structure.==**

This yields a method like the following:

```java
/** Returns the size of the list starting at IntNode p. */
private static int size(IntNode p) {
    if (p.next == null) {
        return 1;
    }

    return 1 + size(p.next);
}
```

Using this method, we can easily compute the size of the entire list:

```java
public int size() {
    return size(first);
}
```

Here, we have two methods, both named `size`. This is allowed in Java, since they have different parameters. **We say that two methods with the same name but different signatures are ==overloaded(重载)==. For more on overloaded methods, see Java's [official documentation](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html).**

An alternate approach is to create a non-static helper method in the `IntNode` class itself. Either approach is fine, though I personally prefer not having any methods in the `IntNode` class.**另一种方法是在“IntNode”类本身中创建一个非静态帮助器方法。这两种方法都很好，尽管我个人更喜欢在“IntNode”类中没有任何方法。**

==you'll have a public method that speaks the language of mortals and a private method that speaks the language of the gods.你会有一个public的方法，讲凡人的语言，而一个private的方法，说上帝的语言==

## Improvement #5: Caching 缓存

Consider the `size` method we wrote above. Suppose `size` takes 2 seconds on a list of size 1,000. We expect that on a list of size 1,000,000, the `size` method will take 2,000 seconds, since the computer has to step through 1,000 times as many items in the list to reach the end. Having a `size` method that is very slow for large lists is unacceptable, since we can do better.

It is possible to rewrite `size` so that it takes the same amount of time, no matter how large the list.

To do so, we can simply add a `size` variable to the `SLList` class that tracks the current size, yielding the code below. This practice of saving important data to speed up retrieval is sometimes known as **caching**.

```java
public class SLList {
    ... /* IntNode declaration omitted. */
    private IntNode first;
    private int size;

    public SLList(int x) {
        first = new IntNode(x, null);
        size = 1; // 加一个size变量
    }

    public void addFirst(int x) {
        first = new IntNode(x, first);
        size += 1;
    }

    public int size() {
        return size;
    }
    ...
}
```

This modification makes our `size` method incredibly fast, no matter how large the list. Of course, it will also slow down our `addFirst` and `addLast` methods, and also increase the memory of usage of our class, but only by a trivial(微不足道的) amount. In this case, the tradeoff is clearly in favor of creating a cache for size.

## Improvement #6: The Empty List

与第2.1章中的简单“`IntList`”相比，我们的“`SLList`”具有许多优势：

- **Users of a `SLList` never see the `IntList` class.**

  - Simpler to use.
  - More efficient `addFirst` method (exercise 2.2.1).
  - Avoids errors or malfeasance(胡作为非, 违法乱纪) by `IntList` users.
  
- Faster `size` method than possible with `IntList`.

另一个自然优势是，我们将能够轻松实现创建空列表的构造函数。如果列表为空，最自然的方法是将“`first`”设置为“`null`”。这将生成以下构造函数:

```java
public SLList() {
    first = null;
    size = 0;
}
```

不幸的是，如果我们插入到空列表中，这会导致“`addLast`”方法崩溃。由于“`	first`”为“`null`”，尝试在下面的“`while（p.next！=null）`”中访问“`p.next`”会导致null指针异常。

```java
public void addLast(int x) {
    size += 1;
    IntNode p = first;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

**Exercise 2.2.3** Fix the `addLast` method. Starter code [here](https://github.com/Berkeley-CS61B/lectureCode/blob/master/lists2/DIY/fixAddLast/SLList.java).

## Improvement #6b: Sentinel Nodes

One solution to fix `addLast` is to create a special case for the empty list, as shown below:

```java
public void addLast(int x) {
    size += 1;

    if (first == null) {
        first = new IntNode(x, null);
        return;
    }

    IntNode p = first;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

This solution works, but special case code like that shown above should be avoided when necessary. Human beings only have so much working memory, **and thus we want to keep complexity under control wherever possible.** For a simple data structure like the `SLList`, the number of special cases is small. More complicated data structures like trees can get much, much uglier.

A cleaner, though less obvious solution, is to make it so that all `SLLists` are the "same", even if they are empty. We can do this by creating a special node that is always there, which we will call a ==**sentinel node(哨兵节点)**. The sentinel node will hold a value, which we won't care about==.

For example, the empty list created by `SLList L = new SLList()` would be as shown below:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/empty_sentinelized_SLList.png" alt="empty_sentinelized_SLList.png" style="zoom:67%;" />

And a `SLList` with the items 5, 10, and 15 would look like:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/three_item_sentenlized_SLList.png" alt="three_item_sentenlized_SLList.png" style="zoom:67%;" />

In the figures above, the lavender ?? value indicates that we don't care what value is there. Since Java does not allow us to fill in an integer with question marks, we just pick some abitrary value like -518273 or 63 or anything else.

Since a `SLList` without a sentinel has no special cases, we can simply delete the special case from our `addLast` method, yielding:

```java
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

As you can see, this code is much much cleaner!

> 这里的哨兵节点类似于虚拟节点

## ==Invariants 不变量==

==An invariant is a fact about a data structure that is guaranteed to be true (assuming there are no bugs in your code).不变量是关于保证为真的数据结构的事实（假设代码中没有错误）==。

A `SLList` with a sentinel node has at least the following invariants:

- T**he `sentinel` reference always points to a sentinel node.**
- **The front item (if it exists), is always at `sentinel.next.item`.**
- **The `size` variable is always the total number of items that have been added.**

Invariants make it easier to reason about code, and also give you specific goals to strive for in making sure your code works.==**不变量使人们更容易对代码进行推理，也为确保代码正常运行提供了具体的目标**==。

A true understanding of how convenient sentinels are will require you to really dig in and do some implementation of your own. You'll get plenty of practice in project 1. However, I recommend that you wait until after you've finished the next section of this book before beginning project 1.真正了解哨兵是多么的方便，需要你真正的挖掘并自己实现。你将在项目1中得到大量练习。然而，我建议您等到读完本书的下一节之后再开始项目1。

## What Next

Nothing for this chapter. However, if you're taking the Berkeley course, you're welcome to now begin Lab 2.





# DLLists

In Chapter 2.2, we built the `SLList` class, which was better than our earlier naked recursive `IntList` data structure. In this section, we'll wrap(包裹) up our discussion of linked lists, and also start learning the foundations of arrays that we'll need for an array based list we'll call an `AList`. Along the way, we'll also reveal the secret of why we used the awkward name `SLList` in the previous chapter.	在第2.2章中，我们构建了“`SLList`”类，它比我们早期的裸递归“`IntList`”数据结构更好。在本节中，**我们将结束对链接列表的讨论，并开始学习==数组==的基础**，这是我们将称为“`AList`”的基于数组的列表所需的基础。在这一过程中，**我们还将揭示为什么我们在上一章中使用了尴尬的名称“`SLList`”的秘密。**

> S:single, 单向链表  D:double, 双向链表

## addLast

Consider the `addLast(int x)` method from the previous chapter.

```java
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```

*The issue with this method is that it is slow*. For a long list, the `addLast` method has to walk through the entire list, much like we saw with the `size` method in chapter 2.2. **Similarly, we can attempt to speed things up by adding a `last` variable, to speed up our code, as shown below:**

```java
public class SLList {
    private IntNode sentinel;
    private IntNode last;
    private int size;    

    public void addLast(int x) {
        last.next = new IntNode(x, null);
        last = last.next;
        size += 1;
    }
    ...
}
```

**Exercise 2.3.1:** 考虑上面表示“`SLList`”实现的方框和指针图，其中包括最后一个指针。假设我们希望支持“`addLast`”、“`getLast`”和“`removeLast`”操作。所示结构是否支持快速的“`addLast`”、“`getLast`”和“`removeLast`”操作？如果没有，哪些操作速度较慢？

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/sllist_last_pointer.png" alt="sllist_last_pointer.png" style="zoom: 67%;" />

**Answer 2.3.1:** `addLast` and `getLast` will be fast, **but `removeLast` will be slow. That's because we have no easy way to get the second-to-last node, to update the `last` pointer, after removing the last node.**

## SecondToLast

练习2.3.1中的结构存在的问题是，删除列表中最后一项的方法本身就很慢。这是因为我们需要首先找到倒数第二个项目，然后将其下一个指针设置为空。==**添加“`secondToLast`”指针也无济于事，因为这样我们就需要找到列表中倒数第三个项目，以确保在删除最后一个项目后，“`secondToLast`”和“`last`”遵循适当的不变量。**==

> **==涉及不变量的概念,非常重要!!!!!!!!!!!!!!!!!!!!!!!!!!!	(明白为什么添加`secondToLast`是不管用的)==**

**Exercise 2.3.2:** 尝试设计一个加快“`removeLast`”操作的方案，使其始终在恒定时间内运行，无论列表有多长。**不要担心实际编写解决方案，我们将留给项目1。**只要想出一个关于如何修改列表结构（即实例变量）的想法。

We'll describe the solution in Improvement #7.

## Improvement #7: Looking Back

> **解决方案就是把单向链表转换成双向链表**

The most natural way to tackle this issue is to add a previous pointer to each `IntNode`, i.e.

```java
public class IntNode {
    public IntNode prev;
    public int item;
    public IntNode next;
}
```

In other words, our list now has two links for every node. One common term for such lists is the "**==Doubly Linked List==**", which we'll call a `DLList` for short. This is in contrast to a single linked list from chapter 2.2, a.k.a. an `SLList`.

添加这些额外的指针将导致额外的代码复杂性。您将在project1中自己构建一个双重链接列表，而不是带您完成它。下面的框和指针图更精确地显示了大小为0和2的列表的双链接列表的外观。

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_0.png" alt="dllist_basic_size_0.png" style="zoom:67%;" />

![dllist_basic_size_2.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png)

## Improvement #8: Sentinel Upgrade

Back pointers allow a list to support adding, getting, and removing the front and back of a list in constant time. There is a subtle issue with this design where the `last` pointer sometimes points at the sentinel node, and sometimes at a real node. Just like the non-sentinel version of the `SLList`, this results in code with special cases that is much uglier than what we'll get after our 8th and final improvement. (Can you think of what `DLList` methods would have these special cases?)

> 但是在实际编写过程中会发现一个特殊情况会导致有问题,就是同时指向哨兵节点, 有两个解决方案
>
> 第一个是再加一个尾部的哨兵节点, 第二个是让哨兵节点的prev和next都指向自己

**One fix is to add a second sentinel node to the back of the list. This results in the topology shown below as a box and pointer diagram.**

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_double_sentinel_size_0.png" alt="dllist_double_sentinel_size_0.png" style="zoom:67%;" />

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_double_sentinel_size_2.png" alt="dllist_double_sentinel_size_2.png" style="zoom:67%;" />

**An alternate approach is to implement the list so that it is circular, with the front and back pointers sharing the same sentinel node.**

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_0.png" alt="dllist_circular_sentinel_size_0.png" style="zoom:67%;" />

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" alt="dllist_circular_sentinel_size_2.png" style="zoom:67%;" />

> 两种方法都可以, 老师更推荐第二种, 我们会在lab1中体验如何编写

## Generic DLLists 通用双向链表(泛型)

我们的DLL列表有一个主要限制：它们只能保存整数值。例如，假设我们想要创建一个字符串列表：

```java
DLList d2 = new DLList("hello");
d2.addLast("world");
```

The code above would crash, since our `DLList` constructor and `addLast` methods only take an integer argument.

==Luckily, in 2004, the creators of Java added **generics** to the language==, which will allow you to, among other things, create data structures that hold any reference type.

The syntax is a little strange to grasp at first. The basic idea is that right after the name of the class in your class declaration, you use an arbitrary placeholder inside angle brackets: `<>`. Then anywhere you want to use the arbitrary type, you use that placeholder instead.起初，语法理解起来有点奇怪。基本思想是，在类声明中的类名称之后，在尖括号内使用任意占位符：“＜＞”。然后，在任何想要使用任意类型的地方，都可以使用占位符。

For example, our `DLList` declaration before was:

```java
public class DLList {
    private IntNode sentinel;
    private int size;

    public class IntNode {
        public IntNode prev;
        public int item;
        public IntNode next;
        ...
    }
    ...
}
```

A generic `DLList` that can hold any type would look as below:

```java
public class DLList<BleepBlorp> {
    private IntNode sentinel;
    private int size;

    public class IntNode {
        public IntNode prev;
        public BleepBlorp item;
        public IntNode next;
        ...
    }
    ...
}
```

在这里，“BleepBlorp”只是我编的一个名字，你可以使用大多数其他你想用的名字，比如“GloopGlop”、“Horse”、“TelbudophMulticulus”或其他任何名字。

既然我们已经定义了“DLL列表”类的通用版本，我们还必须使用特殊语法来实例化这个类。为此，**==我们在声明期间将所需类型放在尖括号内，并在实例化期间使用空的尖括号。==**例如：

> 实例化期间的`<>`可以省略,也可以不省略, 但是最好省略(惯例是这样)

```java
DLList<String> d2 = new DLList<>("hello");
d2.addLast("world");
```

**Since generics only work with reference types, we cannot put primitives like `int` or `double` inside of angle brackets, e.g. `<int>`. Instead, we use the reference version of the primitive type, which in the case of `int` case is `Integer`, e.g.由于泛型只适用于引用类型，因此我们不能将像“int”或“double”这样的原语放在尖括号内，例如“＜int＞”。相反，我们使用原始类型的引用版本，在“int”情况下，它是“Integer”，例如。**

```java
DLList<Integer> d1 = new DLList<>(5);
d1.insertFront(10);
```

使用泛型类型还有其他细微差别，但我们将把它们推迟到本书的后一章, 当您有更多机会自己尝试它们时. 现在,使用以下经验法则：

- In the .java file **implementing** a data structure, specify your generic type name only once at the very top of the file after the class name.
- In other .java files, which use your data structure, specify the specific desired type during declaration, and use the empty diamond operator during instantiation.
- If you need to instantiate a generic over a primitive type, use `Integer`, `Double`, `Character`, `Boolean`, `Long`, `Short`, `Byte`, or `Float` instead of their primitive equivalents.

**Minor detail: You may also declare the type inside of angle brackets when instantiating, though this is not necessary, so long as you are also declaring a variable on the same line. In other words, the following line of code is perfectly valid, even though the `Integer` on the right hand side is redundant.**

```java
DLList<Integer> d1 = new DLList<Integer>(5);
```

此时，您已经了解了在project1上实现“`LinkedListDeque`”项目所需的所有知识，在这里您将完善在第2.1、2.2和2.3章中获得的所有知识!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### What Next

- The first part of [Project 1](https://sp19.datastructur.es/materials/proj/proj1a/proj1a), where you implement `LinkedListDeque.java`.







# Arrays

到目前为止，我们已经了解了如何利用递归类定义来创建可扩展列表类，包括“`IntList`”、“`SLList`”和“`DLList`”。**在本书的下两节中，我们将讨论如何使用数组(arrays)构建列表类。**

本书的这一部分假设您已经使用过数组，并不打算作为其语法的全面指南。

## Array Basics

To ultimately build a list that can hold information, we need some way to get memory boxes. Prevously, we saw how we could get memory boxes with variable declarations and class instantiations. For example:

- `int x;` gives us a 32 bit memory box that stores ints.
- `Walrus w1;` gives us a 64 bit memory box that stores Walrus references.
- `Walrus w2 = new Walrus(30, 5.6);` gets us 3 total memory boxes. One 64 bit box that stores Walrus references, one 32 bit box that stores the int size of the Walrus, and a 64 bit box that stores the double tuskSize of the Walrus.

Arrays are a special type of object that consists of a numbered sequence of memory boxes. This is unlike class instances, which have named memory boxes. To get the ith item of an array, we use bracket notation as we saw in HW0 and Project 0, e.g. `A[i]` to get the `i`th element of A.

Arrays consist of:

- A fixed integer length, N
- A sequence of N memory boxes (N = length) where all boxes are of the same type, and are numbered 0 through N - 1.

**Unlike classes, ==arrays do not have methods.==**

## Array Creation

**There are three valid notations for array creation. Try running the code below and see what happens. Click [here](http://pythontutor.com/iframe-embed.html#code=public class ArrayCreationDemo {  public static void main(String[] args) {    int[] x%3B    int[] y%3B    x %3D new int[3]%3B    y %3D new int[]{1, 2, 3, 4, 5}%3B    int[] z %3D {9, 10, 11, 12, 13}%3B } }&codeDivHeight=400&codeDivWidth=350&cumulative=false&curInstr=0&heapPrimitives=false&origin=opt-frontend.js&py=java&rawInputLstJSON=[]&textReferences=false) for an interactive visualization.**

- `x = new int[3];`
- `y = new int[]{1, 2, 3, 4, 5};`
- `int[] z = {9, 10, 11, 12, 13};`

> 以上三种都是可以的, 但是注意**==第三种必须在声明时使用, 已经声明了的是不能使用的==**
>
> 不指定的时候会**==使用初始值 (对应元素的类型的初始值)==**

## Array Access and Modification

下面的代码展示了我们将用于处理数组的所有关键语法。尝试逐步阅读下面的代码，确保您了解每行执行时发生的情况。要执行此操作，请单击[此处](https://goo.gl/bertuh)用于交互式可视化。除了最后一行代码外，我们以前见过所有这种语法。

```java
int[] z = null;
int[] x, y;

x = new int[]{1, 2, 3, 4, 5};
y = x;
x = new int[]{-1, 2, 5, 4, 99};
y = new int[3];
z = new int[0];
int xL = x.length;

String[] s = new String[6];
s[4] = "ketchup";
s[x[3] - x[1]] = "muffins";

int[] b = {9, 10, 11};
System.arraycopy(b, 0, x, 3, 2);
```

The final line demonstrates one way to copy information from one array to another. `System.arraycopy` takes five parameters:

- The array to use as a source
- Where to start in the source array
- The array to use as a destination
- Where to start in the destination array
- How many items to copy

For Python veterans, `System.arraycopy(b, 0,x, 3, 2)` is the equivalent of `x[3:5] = b[0:2]` in Python.

复制数组的另一种方法是使用循环`arraycopy`通常比循环更快，并导致代码更紧凑。唯一的缺点是“`arraycopy`”（可以说）更难读。**注意，==Java数组只在运行时执行边界检查!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!==。也就是说，以下代码编译得很好，但在运行时会崩溃。**

```java
int[] x = {9, 10, 11, 12, 13};
int[] y = new int[2];
int i = 0;
while (i < x.length) {
    y[i] = x[i];
    i += 1;
}
```

Try running this code locally in a java file or in the [visualizer](https://goo.gl/YHufJ6). What is the name of the error that you encounter when it crashes? Does the name of the error make sense?

> java.lang.ArrayIndexOutOfBoundsException: 2

## 2D Arrays in Java Java中的二维数组

What one might call a 2D array in Java **is actually just an array of arrays**. They follow the same rules for objects that we've already learned, but let's review them to make sure we understand how they work.

==**Syntax for arrays of arrays can be a bit confusing. Consider the code `int[][] bamboozle = new int[4][]`. This creates an array of integer arrays called `bamboozle`. Specifically, this creates exactly four memory boxes, each of which can point to an array of integers (of unspecified length).建立了四个内存盒, 每个内存盒指向一个长度未确定整数的数组**==

试着逐行运行下面的代码，看看结果是否符合你的直觉。有关交互式可视化，请单击[此处](http://goo.gl/VS4cOK).

```java
int[][] pascalsTriangle;
pascalsTriangle = new int[4][];
int[] rowZero = pascalsTriangle[0];

pascalsTriangle[0] = new int[]{1};
pascalsTriangle[1] = new int[]{1, 1};
pascalsTriangle[2] = new int[]{1, 2, 1};
pascalsTriangle[3] = new int[]{1, 3, 3, 1};
int[] rowTwo = pascalsTriangle[2];
rowTwo[1] = -5;

int[][] matrix;
matrix = new int[4][];
matrix = new int[4][4];

int[][] pascalAgain = new int[][]{{1}, {1, 1},
                                 {1, 2, 1}, {1, 3, 3, 1}};
```

![image-20230123222941229](C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230123222941229.png)

> **==注意!!! 等式的黄金原则!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!==**
>
> **==所以第9行赋值给`rowTwo`的应该是地址!!!!!!==**

![image-20230123222947058](C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230123222947058.png)

**Exercise 2.4.1:** After running the code below, what will be the values of x\[0][0] and w\[0][0]? Check your work by clicking [here](http://goo.gl/fCZ9Dr).

```java
int[][] x = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

int[][] z = new int[3][];
z[0] = x[0];
z[1] = x[1];
z[2] = x[2];
z[0][0] = -z[0][0];

int[][] w = new int[3][3];
System.arraycopy(x[0], 0, w[0], 0, 3);
System.arraycopy(x[1], 0, w[1], 0, 3);
System.arraycopy(x[2], 0, w[2], 0, 3);
w[0][0] = -w[0][0];
```

上面的例子表明, **arraycopy只是复制副本而已**

## Arrays vs. Classes

Both arrays and classes can be used to organize a bunch of memory boxes. In both cases, the number of memory boxes is fixed, i.e. the length of an array cannot be changed, just as class fields cannot be added or removed.

The key differences between memory boxes in arrays and classes:数组和类中内存盒的主要区别：

- Array boxes are numbered and accessed using `[]` notation, and class boxes are named and accessed using dot notation.数组框使用“`[]`”符号进行编号和访问，类框使用点符号进行命名和访问。
- Array boxes must all be the same type. Class boxes can be different types.数组框的类型必须相同。类框可以是不同的类型.

One particularly notable impact of these difference is that **==`[]` notation allows us to specify which index we'd like at runtime.==** For example, consider the code below:这些差异的一个特别显著的影响是，“`[]`”表示法允许我们在运行时指定所需的索引。例如，考虑以下代码：

```java
int indexOfInterest = askUserForInteger();
int[] x = {100, 101, 102, 103};
int k = x[indexOfInterest];
System.out.println(k);
```

If we run this code, we might get something like:

```bash
$ javac arrayDemo
$ java arrayDemo
What index do you want? 2
102
```

**By contrast, ==specifying fields in a class is not something we do at runtime.==** For example, consider the code below:

```java
String fieldOfInterest = "mass";
Planet p = new Planet(6e24, "earth");
double mass = p[fieldOfInterest];
```

If we tried compiling this, we'd get a syntax error.

```bash
$ javac classDemo
FieldDemo.java:5: error: array required, but Planet found
        double mass = earth[fieldOfInterest];        
                               ^
```

The same problem occurs if we try to use dot notation:

```java
String fieldOfInterest = "mass";
Planet p = new Planet(6e24, "earth");
double mass = p.fieldOfInterest;
```

Compiling, we'd get:

```bash
$ javac classDemo
FieldDemo.java:5: error: cannot find symbol
        double mass = earth.fieldOfInterest;        
                           ^
  symbol:   variable fieldOfInterest
  location: variable earth of type Planet
```

This isn't a limitation you'll face often, but it's worth pointing out, just for the sake of good scholarship. For what it's worth, there is a way to specify desired fields at runtime called *reflection*, but it is considered very bad coding style for typical programs. You can read more about reflection [here](https://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html). **You should never use reflection in any 61B program**, and we won't discuss it in our course.这不是你经常会遇到的限制，但为了获得好的奖学金，值得指出。值得一提的是，有一种在运行时指定所需字段的方法叫做*reflection*，但对于典型的程序来说，它被认为是非常糟糕的编码风格。你可以在[这里](https://docs.oracle.com/javase/tutorial/reflect/member/fieldValues.html)阅读更多关于reflection的内容. **你不应该在任何61B程序中使用reflection**，我们不会在课程中讨论它。

> 先略过, 以后有机会再学

一般来说，==编程语言的设计部分是为了限制程序员的选择，使代码更易于推理==。==通过将这些特性限制在特殊的reflection API中，我们使***典型的*Java程序更易于阅读和解释**==。

## Appendix: Java Arrays vs. Other Languages

Compared to arrays in other languages, Java arrays:

- Have no special syntax for "slicing" (such as in Python).
- Cannot be shrunk or expanded (such as in Ruby).
- Do not have member methods (such as in Javascript).
- ==Must contain values only of the same type (unlike Python)==.







# AList

In this section, we'll build a new class called `AList` that can be used to store arbitrarily long lists of data, similar to our `DLList`. Unlike the `DLList`, the `AList` will use arrays to store data instead of a linked list.

## Linked List Performance Puzzle

Suppose we wanted to write a new method for `DLList` called `int get(int i)`. Why would `get` be slow for long lists compared to `getLast`? For what inputs would it be especially slow?

You may find the figure below useful for thinking about your answer.

![dllist_circular_sentinel_size_2.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png)

## Linked List Performance Puzzle Solution

It turns out that no matter how clever you are, the `get` method will usually be slower than `getBack` if we're using the doubly linked list structure described in section 2.3.

This is because, since we only have references to the first and last items of the list, we'll always need to walk through the list from the front or back to get to the item that we're trying to retrieve. For example, if we want to get item #417 in a list of length 10,000, we'll have to walk across 417 forward links to get to the item we want.

In the very worst case, the item is in the very middle and we'll need to walk through a number of items proportional to the length of the list (specifically, the number of items divided by two). In other words, our worst case execution time for `get` is linear in the size of the entire list. This in contrast to the runtime for `getBack`, which is constant, no matter the size of the list. Later in the course, we'll formally define runtimes in terms of big O and big Theta notation. For now, we'll stick to an informal understanding.

## Our First Attempt: The Naive Array Based List

Accessing the `i`th element of an array takes constant time on a modern computer. This suggests that an array-based list would be capable of much better performance for `get` than a linked-list based solution, since it can simply use bracket notation to get the item of interest.

If you'd like to know **why** arrays have constant time access, check out this [Quora post](https://www.quora.com/Why-does-accessing-an-array-element-take-constant-time).

**Optional Exercise 2.5.1:** Try to build an AList class that supports `addLast`, `getLast`, `get`, and `size` operations. Your AList should work for any size array up to 100. For starter code, see https://github.com/Berkeley-CS61B/lectureCode/tree/master/lists4/DIY.

[My solution](https://github.com/Berkeley-CS61B/lectureCode/tree/master/lists4/naive) has the following handy invariants.

- The position of the next item to be inserted (using `addLast`) is always `size`.
- The number of items in the AList is always `size`.
- The position of the last item in the list is always `size - 1`.

Other solutions might be slightly different.

## removeLast

The last operation we need to support is `removeLast`. Before we start, we make the following key observation: Any change to our list must be reflected in a change in one or more memory boxes in our implementation.

This might seem obvious, but there is some profundity to it. The list is an abstract idea, and the `size`, `items`, and `items[i]` memory boxes are the concrete representation of that idea. Any change the user tries to make to the list using the abstractions we provide (`addLast`, `removeLast`) must be reflected in some changes to these memory boxes in a way that matches the user's expectations. Our invariants provide us with a guide for what those changes should look like.

**Optional Exercise 2.5.2:** Try to write `removeLast`. Before starting, decide which of `size`, `items`, and `items[i]` needs to change so that our invariants are preserved after the operation, i.e. so that future calls to our methods provide the user of the list class with the behavior they expect.

## Naive Resizing Arrays

**Optional Exercise 2.5.3:** Suppose we have an AList in the state shown in the figure below. What will happen if we call `addLast(11)`? What should we do about this problem?

![dllist_circular_sentinel_size_2.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig25/full_naive_alist.png)

The answer, in Java, is that we simply build a new array that is big enough to accomodate the new data. For example, we can imagine adding the new item as follows:

```java
int[] a = new int[size + 1];
System.arraycopy(items, 0, a, 0, size);
a[size] = 11;
items = a;
size = size + 1;
```

The process of creating a new array and copying items over is often referred to as "resizing". It's a bit of a misnomer since the array doesn't actually change size, we are just making a **new** one that has a bigger size.

**Exercise 2.5.4:** Try to implement the `addLast(int i)` method to work with resizing arrays.

## Analyzing the Naive Resizing Array

The approach that we attempted in the previous section has terrible performance. By running a simple computational experiment where we call `addLast` 100,000 times, we see that the `SLList` completes so fast that we can't even time it. By contrast our array based list takes several seconds.

To understand why, consider the following exercise:

**Exercise 2.5.5:** Suppose we have an array of size 100. If we call insertBack two times, how many total boxes will we need to create and fill throughout this entire process? How many total boxes will we have at any one time, assuming that garbage collection happens as soon as the last reference to an array is lost?

**Exercise 2.5.6:** Starting from an array of size 100, approximately how many memory boxes get created and filled if we call `addLast` 1,000 times?

Creating all those memory boxes and recopying their contents takes time. In the graph below, we plot total time vs. number of operations for an SLList on the top, and for a naive array based list on the bottom. The SLList shows a straight line, which means for each `add` operation, the list takes the same additional amount of time. This means each single operation takes constant time! You can also think of it this way: the graph is linear, indicating that each operation takes constant time, since the integral of a constant is a line.

By contrast, the naive array list shows a parabola, indicating that each operation takes linear time, since the integral of a line is a parabola. This has significant real world implications. For inserting 100,000 items, we can roughly compute how much longer by computing the ratio of N^2/N. Inserting 100,000 items into our array based list takes (100,000^2)/100,000 or 100,000 times as long. This is obviously unacceptable.

## Geometric Resizing

We can fix our performance problems by growing the size of our array by a multiplicative amount, rather than an additive amount. That is, rather than **adding** a number of memory boxes equal to some resizing factor `RFACTOR`:

```java
public void insertBack(int x) {
    if (size == items.length) {
           resize(size + RFACTOR);
    }
    items[size] = x;
    size += 1;
}
```

We instead resize by **multiplying** the number of boxes by `RFACTOR`.

```java
public void insertBack(int x) {
    if (size == items.length) {
           resize(size * RFACTOR);
    }
    items[size] = x;
    size += 1;
}
```

Repeating our computational experiment from before, we see that our new `AList` completes 100,000 inserts in so little time that we don't even notice. We'll defer a full analysis of why this happens until the final chapter of this book.



<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230124115532835.png" alt="image-20230124115532835" style="zoom:67%;" />



## Memory Performance

Our `AList` is almost done, but we have one major issue. Suppose we insert 1,000,000,000 items, then later remove 990,000,000 items. In this case, we'll be using only 10,000,000 of our memory boxes, leaving 99% completely unused.

To fix this issue, we can also downsize our array when it starts looking empty. Specifically, we define a "usage ratio" R which is equal to the size of the list divided by the length of the `items` array. For example, in the figure below, the usage ratio is 0.04.

![fig25/usage_ratio.png](https://joshhug.gitbooks.io/hug61b/content/chap2/fig25/usage_ratio.png)

In a typical implementation, we halve the size of the array when R falls to less than 0.25.

## Generic ALists

Just as we did before, we can modify our `AList` so that it can hold any data type, not just integers. To do this, we again use the special angle braces notation in our class and substitute our arbitrary type parameter for integer wherever appropriate. For example, below, we use `Glorp` as our type parameter.

There is one significant syntactical difference: Java does not allow us to create an array of generic objects due to an obscure issue with the way generics are implemented. That is, we cannot do something like:

```java
Glorp[] items = new Glorp[8];
```

Instead, we have to use the awkward syntax shown below:

```java
Glorp[] items = (Glorp []) new Object[8];
```

This will yield a compilation warning, but it's just something we'll have to live with. We'll discuss this in more details in a later chapter.

The other change we make is that we null out any items that we "delete". Whereas before, we had no reason to zero out elements that were deleted, with generic objects, we do want to null out references to the objects that we're storing. This is to avoid "loitering". Recall that Java only destroys objects when the last reference has been lost. If we fail to null out the reference, then Java will not garbage collect the objects that have been added to the list.

This is a subtle performance bug that you're unlikely to observe unless you're looking for it, but in certain cases could result in a significant wastage of memory.

## What's next:

- [Discussion 3](http://sp19.datastructur.es/materials/discussion/disc03.pdf)
- [Lab 2](http://sp19.datastructur.es/materials/lab/lab2/lab2)
- [Project 1A](http://sp19.datastructur.es/materials/proj/proj1a/proj1a)
