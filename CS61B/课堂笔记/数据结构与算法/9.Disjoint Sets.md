# 9.1 Introduction to Disjoint Sets 并查集,不交集

==**Two sets are named *disjoint sets* if they have no elements in common**==. A Disjoint-Sets (or **==Union-Find(并查集)==**) data structure keeps track of a fixed number of elements partitioned into a number of *disjoint sets*. The data structure has two operations:

1. `connect(x, y)`: connect `x` and `y`. Also known as `union`
2. `isConnected(x, y)`: returns true if `x` and `y` are connected (i.e. part of the same set).

A Disjoint Sets data structure **==has a fixed number of elements==** that each start out in their own subset. **By calling `connect(x, y)` for some elements `x` and `y`, we merge subsets together.**

For example, say we have four elements which we'll call A, B, C, D. To start off, each element is in its own set:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro1_resized.png" alt="img" style="zoom: 25%;" />

After calling `connect(A, B)`:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro2_resized.png" alt="img" style="zoom:25%;" />

Note that the subsets A and B were merged. Let's check the output some `isConnected` calls:

```
isConnected(A, B) -> true
isConnected(A, C) -> false
```

After calling `connect(A, D)`:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro3_resized.png" alt="img" style="zoom:25%;" />

We find the set A is part of and merge it with the set D is part of, creating one big A, B, D set. C is left alone.
`isConnected(A, D) -> true`
`isConnected(A, C) -> false`

With this intuition in mind, let's formally define what our DisjointSets interface looks like. As a reminder, an **interface** determines *what* behaviors a data structure should have (but not *how* to accomplish it). For now, we'll only deal with sets of non-negative integers. This is not a limitation because in production we can assign integer values to anything we would like to represent.考虑到这种直觉，让我们正式定义DisjointSets接口的外观。作为提醒，==**接口决定了数据结构应该具有的行为（而不是如何实现）!!!!!!!!!!!!!!!**==。现在，我们只处理非负整数的集合。这不是一个限制，因为在生产中，我们可以将整数值分配给任何我们想表示的值。

```java
public interface DisjointSets {
    /** connects two items P and Q */
    void connect(int p, int q);

    /** checks to see if two items are connected */
    boolean isConnected(int p, int q); 
}
```

In addition to learning about how to implement a fascinating data structure, this chapter will be a chance to see how an implementation of a data structure evolves. We will discuss four iterations of a Disjoint Sets design before being satisfied: *Quick Find → Quick Union → Weighted Quick Union (WQU) → WQU with Path Compression*. **We will see how design decisions greatly affect asymptotic runtime and code complexity.**除了学习如何实现一个迷人的数据结构之外，本章还将提供一个机会来了解数据结构的实现是如何演变的。在满足之前，我们将讨论并查集设计的四次迭代：*快速查找→ 快速接头→ 加权快速接头（WQU）→ 具有路径压缩*的WQU. **我们将看到设计决策如何极大地影响渐近运行时和代码复杂性**

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230201232738364.png" alt="image-20230201232738364" style="zoom: 20%;" />

> ==只用记录每个元素属于哪个集合==

# 9.2 Quick Find

现在我们讨论如何实现“DisjointSets”接口的所需行为。我们的挑战是跟踪集合成员。

## ListOfSets

Intuitively, we might first consider representing Disjoint Sets as a list of sets, e.g, `List<Set<Integer>>`.

For instance, if we have N=6 elements and nothing has been connected yet, our list of sets looks like: `[{0}, {1}, {2}, {3}, {4}, {5}, {6}]`. Looks good. However, consider how to complete an operation like `connect(5, 6)`. We'd have to iterate through up to `N` sets to find 5 and `N` sets to find 6. Our runtime becomes `O(N)`. And, if you were to try and implement this, the code would be quite complex. 即,耗费时间过多(要遍历), 且代码写起来很麻烦

> The lesson to take away is that **==initial design decisions determine our code complexity and runtime.最初的设计决定决定了我们的代码复杂性和运行时==**

## Quick Find

Let's consider another approach using a *single array of integers*.

- The **indices(指数,索引) of the array** represent the elements of our set.
- The **value at an index** is the set number it belongs to.

For example, we represent `{0, 1, 2, 4}, {3, 5}, {6}` as:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.2.1.png" alt="img" style="zoom:33%;" />

The array indices (0...6) are the elements. The value at `id[i]` is the set it belongs to. ***The specific set number doesn't matter as long as all elements in the same set share the same id.只要同一集合中的所有元素共享相同的id，那么特定的集合编号无关紧要。***

### `connect(x, y)`

Let's see how the connect operation would work. Right now, `id[2] = 4` and `id[3] = 5`. After calling `connect(2, 3)`, all the elements with id 4 and 5 should have the same id. Let's assign them all the value 5 for now:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.2.2.png" alt="img" style="zoom: 33%;" />

### `isConnected(x, y)`

To check `isConnected(x, y)`, we simply check if `id[x] == id[y]`. Note this is a constant time operation!

We call this implementation "Quick Find" because finding if elements are connected takes constant time.

### Summary and Code

| Implementation | Constructor | `connect` | `isConnected` |
| -------------- | ----------- | --------- | ------------- |
| ListOfSets     | Θ(N)        | O(N)      | O(N)          |
| QuickFind      | Θ(N)        | Θ(N)      | Θ(1)          |

N = number of elements in our DisjointSets data structure

```java
public class QuickFindDS implements DisjointSets {

    private int[] id;

    /* Θ(N) */
    public QuickFindDS(int N){
        id = new int[N];
        for (int i = 0; i < N; i++){
            id[i] = i;
        }
    }

    /* need to iterate through the array => Θ(N) */
    public void connect(int p, int q){
        int pid = id[p];
        int qid = id[q];
        for (int i = 0; i < id.length; i++){
            if (id[i] == pid){
                id[i] = qid;
            }
        }
    }

    /* Θ(1) */
    public boolean isConnected(int p, int q){
        return (id[p] == id[q]);
    }
}
```

> \1. We didn't discuss this but you can reason that having to create N distinct sets initially is Θ(N)



# 9.3 Quick Union

**Suppose we prioritize making the `connect` operation fast**. We will still represent our sets with an array. Instead of an id, we assign each item the index of its parent. If an item has no parent, then it is a 'root' and we assign it a negative value.

This approach allows us to imagine each of our sets as a tree. For example, we represent `{0, 1, 2, 4}, {3, 5}, {6}` as:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.3.1.png" alt="img" style="zoom: 33%;" /> Note that we represent the sets using **only an array**. We visualize it ourselves as trees.

For QuickUnion we define a helper function `find(int item)` which returns the root of the tree `item` is in. For example, for the sets above, `find(4) == 0`, `find(1) == 0`, `find(5) == 3`, etc. Each element has a unique root.

#### `connect(x, y)`

To connect two items, we find the set that each item belongs to (the roots of their respective trees), and make one the child of the other. Example:为了连接两个项目，我们找到每个项目所属的集合（它们各自树的根），并使一个项目成为另一个项目的子项目。例子：

`connect(5, 2)`:

1. `find(5)` -> 3
2. `find(2)` -> 0
3. Set `find(5)`'s value to `find(2)` aka `parent[3] = 0`

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.3.2.png" alt="img" style="zoom:33%;" /> 

Note how element 3 now points to element 0, combining the two trees/sets into one.

In the best case, if `x` and `y` are both roots of their trees, then `connect(x, y)` just makes `x` point to `y`, a Θ(1) operation! (Hence the name QuickUnion)

#### `isConnected(x, y)`

If two elements are part of the same set, then they will be in the same tree. Thus, they will have the same root. So for `isConnected(x, y)` we simply check if `find(x) == find(y)`.

### Performance

There is a potential performance issue with QuickUnion: the tree can become very long. In this case, finding the root of an item (`find(item)`) becomes very expensive. Consider the tree below:QuickUnion存在一个潜在的性能问题：树可能会变得很长。在这种情况下，查找项目的根（“find（item）”）变得非常昂贵。考虑下面的树：

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.3.3.png" alt="img" style="zoom:33%;" />

In the worst case, we have to traverse all the items to get to the root, which is a Θ(N) runtime. Since we have to call `find` for both `connect` and `isConnected`, the runtime for both is upper bounded by O(N).  在最坏的情况下，我们必须遍历所有项才能到达根，这是一个Θ（N）运行时。由于我们必须同时为“connect”和“isConnected”调用“find”，因此两者的运行时都由O（N）上限。

### Summary and Code

| Implementation | Constructor | `connect` | `isConnected` |
| -------------- | ----------- | --------- | ------------- |
| QuickUnion     | Θ(N)        | O(N)      | O(N)          |
| QuickFind      | Θ(N)        | Θ(N)      | Θ(1)          |
| QuickUnion     | Θ(N)        | O(N)      | O(N)          |

N = number of elements in our DisjointSets data structure

From the runtime chart, QuickUnion seems worse than QuickFind! Note however that O(N) as an **upper bound**. When our trees are balanced, both `connect` and `isConnected` perform reasonably well. In the next section we'll see how to *guarantee* they perform well.从运行时图表来看，QuickUnion似乎比QuickFind更糟糕！然而，注意O（N）作为**上界**。当我们的树平衡时，“connect”和“isConnected”都表现得相当好。在下一节中，我们将看到如何“保证”他们表现良好。

```java
public class QuickUnionDS implements DisjointSets {
    private int[] parent;

    public QuickUnionDS(int num) {
        parent = new int[num];
        for (int i = 0; i < num; i++) {
            parent[i] = i;
        }
    }

    private int find(int p) {
        while (parent[p] >= 0) {
            p = parent[p];
        }
        return p;
    }

    @Override
    public void connect(int p, int q) {
        int i = find(p);
        int j = find(q);
        parent[i] = j;
    }

    @Override
    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }
}
```



# 9.4 Weighted(加权) Quick Union (WQU)

> **==这个"权"不是高度, 而是个数(size)==**

Improving on Quick Union relies on a key insight: whenever we call `find`, we have to climb to the root of a tree. Thus, the shorter the tree the faster it takes!改进Quick Union依赖于一个关键的洞察力：每当我们调用“find”时，我们都必须爬到树根。因此，**树越短，速度越快！**

**New rule:** whenever we call `connect`, we always link the root of the **smaller** tree **to the larger** tree.	**新规则：**每当我们调用“connect”时，我们总是将**较小的**树**的根链接到较大的**树。

Following this rule will give your trees a maximum height of `logN`, where N is the number of elements in our Disjoint Sets. How does this affect the runtime of `connect` and `isConnected`?

Let's illustrate the benefit of this with an example. Consider connecting the two sets T1 and T2 below:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.1.png" alt="img" style="zoom:33%;" />

We have two options for connecting them:

<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.2.png" alt="img" style="zoom: 33%;" /> 

The first option we link T1 to T2. In the second, we link T2 to T1.

The **second option is preferable** as it only has a height of 2, rather than 3. By our new rule, we would choose the second option as well because T2 is smaller than T1 (size of 3 compared to 6).

We determine smaller / larger by the number of items in a tree. Thus, when connecting two trees we need to know their size (or weight). We can store this information in the root of the tree by replacing the `-1`'s with `-(size of tree)`. 

#### Maximum height: Log N

Following the above rule ensures that the *maximum* height of any tree is Θ(log N). N is the number of elements in our Disjoint Sets. **By extension, the runtimes of `connect` and `isConnected` are bounded by O(log N).**

![image-20230202000617025](C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230202000617025.png)

You may be wondering why we don't link trees based off of height instead of weight. It turns out this is more complicated to implement and gives us the same Θ(log N) height limit.

### Summary and Code

| Implementation       | Constructor | `connect` | `isConnected` |
| -------------------- | ----------- | --------- | ------------- |
| QuickUnion           | Θ(N)        | O(N)      | O(N)          |
| QuickFind            | Θ(N)        | Θ(N)      | Θ(1)          |
| QuickUnion           | Θ(N)        | O(N)      | O(N)          |
| Weighted Quick Union | Θ(N)        | O(log N)  | O(log N)      |

N = number of elements in our DisjointSets data structure

Code? That's your [Lab 6](https://sp19.datastructur.es/materials/lab/lab6/lab6)!

# 9.5 Weighted Quick Union with Path Compression

Weighted Quick Union is pretty good, but we can do even better!

The clever insight is realizing that whenever we call `find(x)` we have to traverse the path from `x` to root. So, along the way we can connect all the items we visit to their root at no extra asymptotic cost.

Connecting all the items along the way to the root will help make our tree shorter with each call to `find`.

Recall that **both `connect(x, y)` and `isConnected(x, y)` always call `find(x)` and `find(y)`.** Thus, after calling `connect` or `isConnected` enough, essentially all elements will point directly to their root.

By extension, the average runtime of `connect` and `isConnected` becomes **almost constant** in the long term! This is called the *amortized runtime* (from [amortized analysis, ch. 8.4](https://joshhug.gitbooks.io/hug61b/content/chap8/chap84.html#amortized)).

More specifically, for M operations on N elements, WQU with Path Compression is in O(N + M (lg* N)). lg* is the [iterated logarithm](https://en.wikipedia.org/wiki/Iterated_logarithm) which is less than 5 for any real-world input. 

N: number of elements in Disjoint Set

| Implementation             | `isConnected` | `connect` |
| -------------------------- | ------------- | --------- |
| Quick Find                 | Θ(N)          | Θ(1)      |
| Quick Union                | O(N)          | O(N)      |
| Weighted Quick Union (WQU) | O(log N)      | O(log N)  |
| WQU with Path Compression  | O(α(N))*      | O(α(N))*  |

\* ==**behaves as constant in long term.**==

Code? This is your [lab 6](https://sp19.datastructur.es/materials/lab/lab6/lab6)!

> Students interested in understanding where the iterated logarithm comes from can read [this proof](https://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union-find) or page 9 from these [170 notes](https://people.eecs.berkeley.edu/~vazirani/algorithms/chap5.pdf). Path compression is actually even better than iterated log - it's bounded by the inverse [Ackermann function α](https://www.uni-trier.de/fileadmin/fb4/prof/INF/DEA/Uebungen_LVA-Ankuendigungen/ws07/KAuD/effi.pdf) which is comically out of scope.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203143500801.png" alt="image-20230203143500801" style="zoom: 20%;" /><img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203143509971.png" alt="image-20230203143509971" style="zoom:20%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203143534035.png" alt="image-20230203143534035" style="zoom: 20%;" /><img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203143540730.png" alt="image-20230203143540730" style="zoom:20%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203143642714.png" alt="image-20230203143642714" style="zoom: 33%;" />



