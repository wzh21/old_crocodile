# 12.1 A first attempt

## Issues with what we've seen so far

So far, we've looked at a few data structures **for efficiently searching for the existence of items** within the data structure. We looked at Binary Search Trees, then made them balanced using 2-3 Trees.

However, there are **some limitations** that these structures impose (yes, even 2-3 trees!)

1. **They require that items be comparable.** How do you decide where a new item goes in a BST? You have to answer the question "are you smaller than or bigger than the root"? **For some objects, this question may make no sense.**
2. They give a complexity of **Θ(log*N*)**. Is this good? Absolutely. **But maybe we can do better.**

### A first attempt: `DataIndexedIntegerSet`

Let us begin by considering the following approach.

For now, we're **only** going to try to improve issue #2 above (improve complexity from Θ(log*N*) to Θ(1)). We're going to **not worry about** issue #1 (comparability). In fact, **we're going to only consider storing and searching for `int`s.**

Here's an idea: let's create an ArrayList of type `boolean` and size 2 billion. Let everything be false by default.

- The `add(int x)` method simply sets the `x` position in our ArrayList to true. This takes Θ(1) time.
- The `contains(int x)` method simply returns whether the `x` position in our ArrayList is `true` or `false`. This also takes Θ(1) time!

```java
public class DataIndexedIntegerSet {
    private boolean[] present;

    public DataIndexedIntegerSet() {
        present = new boolean[2000000000];
    }

    public void add(int x) {
        present[i] = true;
    }

    public boolean contains(int x) {
        return present[i];
    }
```

There, we have it. That's all folks.

Well, not really. What are some potential **issues** with this approach?

- **Extremely wasteful.** If we assume that a `boolean` takes 1 byte to store, the above needs `2GB` of space per `new DataIndexedIntegerSet()`. Moreover, **the user may only insert a handful of items...**

- What do we do if someone wants to insert a`String`?

  - Let's look at this next. Of course, we may want to insert other things, like `Dog`s. That'll come soon!

# 12.2 Inserting words

## Solving the word-insertion problem

> ==**Hash的由来 : 存储不同类型的对象, 用一个数字(编号)来表示**==

Our `DataIndexedIntegerSet` only allowed for integers, but now we want to insert the `String` `"cat"` into it. We'll call our data structure that can insert strings `DataIntexedEnglishWordSet` Here's a crazy idea: let's give every string a number. Maybe "cat" can be `1`, "dog" can be `2` and "turtle" can be `3`.

(The way this would work is –– if someone wanted to add a "cat" to our data structure, we would 'figure out' that the number for "cat" is 1, and then set `present[1]` to be `true`. If someone wanted to ask us if "cat" is in our data structure, we would 'figure out' that "cat" is 1, and check if `present[1]` is true.)

But then if someone tries to insert the word "potatocactus", we'll not know what to do. We need to develop ==**a general strategy**== so that given a string, we can figure out a number representation for it.

### Strategy 1: Use the first letter.

Note that when two different inputs ("dog" and "drum") map to the same integer, we call that a **collision**. We don't know how to **deal with collisions** yet, so let's figure out a way to avoid them. (What we do with most of our problems lol...)

> 行不通, 有可能会重复

### Strategy 2: Avoiding collisions

To motivate this part, let's understand how our number system works.

A four digit number, say 5149, can be written as

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205181204686.png" alt="image-20230205181204686" style="zoom:67%;" />

**==Notice that the `10` is important here. If we chose a bad number, say 2, the same is not true.==** Let's make sure we see what happens if we chose 2 as the multiplier.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205181325724.png" alt="image-20230205181325724" style="zoom:50%;" />

A collision on inputs (1, 1, 1, 1) and (0, 3, 1, 1)!

So why is `10 `important? It's ==**because there are 10 unique digits in our decimal system:**== 0,1,2,3,4,5,6,7,8,9

Similarly, **there are 26 unique characters in the english lowercase alphabet.** Why not give each one a number: `a = 1`,`b = 2`,…,`z = 26`. Now, we can write any unique lowercase string in **base 26**. (==Note that **base 26** simply means that we will use **26** as the multiplier(乘数)==, much like we used **10** and **2** as examples above.)

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205181518822.png" alt="image-20230205181518822" style="zoom:50%;" />

**==This representation gives a unique integer to every english word containing lowercase letters, much like using base 10 gives a unique representation to every number. We are guaranteed to not have collisions.==**

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205182228869.png" alt="image-20230205182228869" style="zoom: 33%;" />

### Our Data Structure `DataIndexedEnglishWordSet`

```java
public class DataIndexedEnglishWordSet {
    private boolean[] present;

    public DataIndexedEnglishWordSet() {
        present = new boolean[2000000000];
    }

    public void add(String s) {
        present[englishToInt(s)] = true;
    }

    public boolean contains(String s) {
        return present[englishToInt(s)];
    }
}
```

Uses a helper method

```java
public static int letterNum(String s, int i) {
    /** Converts ith character of String to a letter number.
    * e.g. 'a' -> 1, 'b' -> 2, 'z' -> 26 */
    int ithChar = s.charAt(i)
    if ((ithChar < 'a') || (ithChar > 'z')) {
        throw new IllegalArgumentException();
    }

    return ithChar - 'a' + 1;
}

public static int englishToInt(String s) {
    int intRep = 0;
    for (int i = 0l i < s.length(); i += 1) {
        intRep = intRep * 26;
        intRep += letterNum(s, i);
    }

    return intRep;
}
```

### Where are we?

Recall, we started with wanting to

(a) Be better than Θ(log*N*). We've now done this for integers and for single english words.

(b) Allow for **non-comparable** items. **We haven't touched this yet**, although we are getting there. So far, we've only learnt how to add integers and english words, both of which *are* comparable, **but**, have we ever **used** the fact that they are comparable? I.e., have we ever tried to compare them (like we did in BSTs)? No. So we're getting there, **but we haven't actually inserted anything non-comparable yet.**

(c) We have data structures that insert integers and english words. Let's make a quick visit to inserting arbitrary `String` objects, with spaces and all that. And maybe even insert other languages and emojis!

(d) Further recall that our approach is still very wasteful of memory. We haven't solved that issue yet!进一步回想一下，**我们的方法仍然非常浪费内存。**我们还没有解决这个问题！

# 12.3 Inserting Strings and Overflow

## Inserting `String`s beyond single english words

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205183842805.png" alt="image-20230205183842805" style="zoom:33%;" />

There is a character format called **ASCII**, which has an integer per character. Here, we see that the largest value (i.e., the base/multiplier we need to use) is 126. Let's just do that. The same thing as `DataIndexedEnglishWordSet`, but just with base `126`.

```java
public static int asciiToInt(String s) {
    int intRep = 0;
    for (int i = 0; i < s.length(); i += 1) {           
        intRep = intRep * 126;
        intRep = intRep + s.charAt(i);
    }
    return intRep;
}
```

What about adding support for Chinese? The largest possible representation is 40959, so we need to use that as the base. Here's an example:

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205184053216.png" alt="image-20230205184053216" style="zoom:50%;" />

==So... to store a 3 character Chinese word, we need an array of size larger than **39 trillion** (with a T)!==. This is getting out of hand... so let's explore what we can do.

> ==要表示整个字符, 会花费特别巨大的空间==

## Handling Integer Overflow and Hash Codes

### Overflow issues : int会溢出

The largest possible value for integers in Java is 2,147,483,647. The smallest value is -2,147,483,648.

If you try to take the largest value and add 1, you get the smallest value!

So, we will run into problems, even with just ASCII characters (which are in base 126, remember).

![image-20230205193545646](C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205193545646.png)

`melt banana` and `subterresetrial anticosmetic` actually have the same representation according to `asciiToInt` because of overflow. So if we added `melt banana` and then tried to ask `contains(subterrestrial anticosmetic)`, we would get `true`.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205211322046.png" alt="image-20230205211322046" style="zoom:25%;" />

### The inevitable truth. 不可避免的事实

From the smallest to the largest possible integers, there are a total of 4,294,967,296 integers in Java. Yet, there are more than that many total objects that could be created in Java, and so collision is inevitable. Resistance is futile. **We must figure out how to deal with collision head-on, instead of trying to work around it.**

(If you don't believe that there are more than 4 billions objects one could create in Java, just consider: "one", "two", ..., "five trillion" –– each of which is a unique string.)

**We must handle collisions.**

> 即我们不能只靠扩大存储空间来避免碰撞的问题

### A subtle point 微妙的一点

Note that our problem is not inherently(固有地) the fact that overflow *exists*. All we wanted was for a way to convert a `String` to a number. Even if overflow *exists*, we do manage to convert a `String` to a number. The inherent problem is caused by the fact that *overflow causes collisions*, which we don't know how to deal with.

Overflow *is* often bad in other contexts, for instance, it has some unexpected results if you don't know that overflow happens. **But here, ==overflow's existence doesn't ruin the fact that we wanted to convert a `String` to an `int`==. So, we have that going for us.**

### Hash Codes

In computer science, ==taking an object and converting it into some integer is called "computing the **hash code** of the object"==. For instance, the hashcode of "melt banana" is 839099497.

We looked at how to compute this hashcode for Strings. **For other Objects**, there are one of two things we do:

- ==**Every Object in Java has a default `.hashcode()` method**, which we can use. Java computes this by figuring out where the `Object` sits in **memory (every section of the memory in your computer has an address!)**, and uses that memory's address to do something similar to what we did with `String`s. This methods gives a *unique* hashcode for every single Java object.==
- Sometimes, we write our own `hashcode` method. For example, given a `Dog`, we may use a combination of its `name`, `age` and `breed` to generate a `hashcode`.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205212351203.png" alt="image-20230205212351203" style="zoom:25%;" />

> pigeonhole principle : 鸽巢原理

## Properties of HashCodes

Hash codes have three necessary properties, which means a hash code must have these properties in order to be ==**valid**:==

1. ==**It must be an Integer**==
2. ==If we run `.hashCode()` on an object **twice,** it should return the **same** number==
3. ==**Two objects that are considered `.equal()` must have the same hash code.**==

Not all hash codes are created equal, however. If you want your hash code to be considered a **good** hash code, it should:

1. Distribute items evenly 均匀分布项目

**Note that at this point, we know how to add ==arbitrary objects== to our data structure, not only strings.**

### Pending issues 未决问题

- Space: we still haven't figured out how to use less space. 空间：我们还没有弄清楚如何使用更少的空间。

- Handling Collisions: we have determined that we need to handle collisions, but we haven't actually handled them yet.

  处理碰撞：我们已经确定我们需要处理碰撞，但我们还没有真正处理它们。

Everything else has been solved!

# 12.4 Handling Collisions

## Handling Collisions

Time to address the elephant in the room. The big idea is to change our array ever so slightly to not contain just items, but instead contain a LinkedList (or any other List) of items. So...

Everything in the array is originally empty.

If we get a new item, and its hashcode is $h$:

- If there is nothing at index $h$ at the moment, we'll create a new `LinkedList` for index $h$, place it there, and then add the new item to the newly created `LinkedList`.
- If there is already something at index $h$, then there is already a `LinkedList` there. We simply add our new item to that `LinkedList`. **Note: Our data structure is not allowed to have any duplicate items / keys. Therefore, we must first check whether the item we are trying to insert is already in this LinkedList. If it is, we do nothing! This also means that we will insert to the END of the linked list, since we need to check all of the elements anyways.**

> 利用Linked List : <img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205213532941.png" alt="image-20230205213532941" style="zoom:25%;" />

### Concrete workflow 具体工作流(流程)

- `add` item
  - Get hashcode (i.e., index) of item.
  - If index has no item, create new List, and place item there.
  - If index has a List already, check the List to see if item is already in there. ==**If *not*, add item to List.**==
- `contains` item
  - Get hashcode (i.e., index) of item.
  - If index is empty, return `false`.
  - Otherwise, check all items in the List at that index, and if the item exists, return `true`.

### Runtime Complexity

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205213828952.png" alt="image-20230205213828952" style="zoom:33%;" />

**Why is contains** Θ(*Q*)?

Because we need to look at all the items in the LinkedList at the hashcode (i.e., index).

**Why is add** Θ(*Q*)?

Can't we just add to the beginning of the LinkedList, which takes Θ(1) time? No! ==Because **we have to check to make sure the item isn't already in the linked list.**==

> ==`add` 是 `Θ(Q)`的, 因为要检查是不是重复!!!==

### You gain some, you lose some.

- Space: Still unsolved.
- Handling collisions: done.
- Runtime complexity? ==**We've lost some.**== In the worst case, all of our items' `hashcode` could be the same, and so they all go to the same index. If we have *N* items, it's possible that they **all** go to the same index, creating a linked list of length N, providing a runtime of Θ(N). 有可能`Q = N` ,导致复杂度是`Θ(N)`

### Solving space

Why keep an ArrayList of size 4 billion around? Recall that we did that to avoid collisions, because we wanted to be able to add every integer / word / `String` to our data structure. But now that we allow for collisions *anyway*, we can relax this a bit.

An idea: modulo. Let's just create an ArrayList of size, say, 100. Let's not change how the `hashcode` functions behaves (let it return a crazy large integer.) But after we get the `hashcode`, we'll take its modulo 100 to get an index within the 0…990…99 range that we want. And if collisions happen? Doesn't matter, we know how to deal with it!

Do note that our LinkedLists within the array will now be longer, because we're taking all the items spread across the 4 billions indices and compressing them into a 100 indices.

> **解决空间问题 : 压缩为100个存储空间(通过模100)**

### Where we are

- Space: Has been solved.
- Handling collisions: Done!
- Runtime complexity? We lost some earlier at Θ(*Q*) for `add` and `contains`, and then in the `Solving space` section, we realized that we lost some more because our LinkedLists will potentially be larger (so `Q` will be larger.)



# 12.5 Hash Table and Fixing Runtime

## Our Final Data Structure: `HashTable`

==**What we've created now is called a `HashTable`.**==

- Inputs are converted by a hash function (`hashcode`) into an integer. Then, they're converted to a valid index using the modulus operator. Then, they're added at that index (dealing with collisions using LinkedLists).
- `contains` works in a similar fashion by figuring out the valid index, and looking in the corresponding LinkedList for the item.

## Dealing with Runtime

The only issue left to solve is the issue of runtime. If we have 100 items, and our ArrayList is of size 5, then

- In the best case, all items get sent to the different indices evenly. That is, we have 5 linkedLists, and each one contains 20 of the items.
- In the worst case, all items get sent to the same index! That is, we have just 1 LinkedList, and it has all 100 items.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205215032284.png" alt="image-20230205215032284" style="zoom:33%;" />

There are two ways to try to fix this:

- **==Dynamically growing our hashtable.==**
- ==**Improving our Hashcodes**==

### Dynamically growing the hash table

Suppose we have *M* buckets (indices) and N items. We say that our **==load factor(负载因子)==** is *N*/*M*.

(Note that the **load factor** is equivalent to our **best** case runtime from above.)

So... we have incentive to keep our load factor low (after all, it is the best runtime we could possible achieve!).

And note that if we keep *M* (the number of buckets) fixed, and N* keeps increasing, the load factor consistently keeps increasing.

Strategy? Every so often, just double M*. The way we do this is as follows:

- Create a new HashTable with **2M** buckets.
- Iterate through all the items in the old HashTable, and one by one, add them into this new HashTable.
  - We need to add elements one by one again because since the size of the array changes, **the modulus also changes**, therefore the item probably belongs in a different bucket in the new hashtable than in the old one.我们需要再次逐个添加元素，因为由于数组的大小发生变化，**==模数也会发生变化==**，因此该项可能属于新哈希表中与旧哈希表中不同的存储桶。

We do this by setting a **==load factor threshold(阈值)==**. As soon as the load factor becomes bigger than this threshold, we resize.

![image-20230205215417607](C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205215417607.png)
<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205215703447.png" alt="image-20230205215703447" style="zoom:33%;" />

![image-20230205215658886](C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205215658886.png)

Note also that resizing takes Θ(*N*) time. Why? Because we need to add *N* items to the hashtable, and each add takes Θ(1) time.

> 但这成立的前提是==**分配的足够均匀**==

A small point: **when doing the resize, we don't actually need to check if the items are already present in the LinkedList or not (because we know there are no duplicates)**, **so we can just add each item in Θ(1) time for sure by adding it to the front of the linked list. (Recall that usually we have to search the LinkedList to make sure the item isn't there... but we can skip that step when resizing.)**

**Of course, we need to revisit our assumption of assuming items are evenly distributed**. If items are not evenly distributed, our runtime will be Θ(*N*) because there could be a single linked list of size *N*.

### Assuming that items are evenly distributed?

Items will distribute evenly if we have good hash codes (i.e. hashcodes which give fairly random values for different items.) Doing this in general is.. well... hard.

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-08%20at%201.44.43%20PM.png)

Some general good rules of thumb: 一些一般的好经验法则：

- Use a 'base' strategy similar to the one we developed earlier.
- Use a 'base' that's a small prime.
  - Base 126 isn't actually very good, because using base 126 means that any string that ends in the same last 32 characters has the same hashcode.
  - This happens because of overflow.
  - ==**Using prime numbers helps avoid overflow issues (i.e., collisions due to overflow).为什么是小素数？因为它更容易计算。**==
  - ==**Why a small prime? Because it's easier to compute.为什么是小素数？因为它更容易计算**==

Some examples

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205220456755.png" alt="image-20230205220456755" style="zoom: 25%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230205220503293.png" alt="image-20230205220503293" style="zoom:25%;" />

# Next Steps

Wow, we've just gone through the creation of a data structure from scratch! Proud of you guys. To apply your knowledge finish HW3: [HW3](https://sp19.datastructur.es/materials/hw/hw3/hw3/)