# 10.1 Intro to ADTs

## ADTs

==**An Abstract Data Type (ADT) is defined only by its operations, not by its implementation. **==For example in proj1a, we developed an ArrayDeque and a LinkedListDeque that had the same methods, but how those methods were written was very different. In this case, we say that ArrayDeque and LinkedListDeque are *implementations* of the Deque ADT. From this description, we see that ADT's and interfaces are somewhat related. **Conceptually, Deque is an interface for which ArrayDeque and LinkedListDeque are its implementations. In code, in order to express this relationship, we have the ArrayDeque and LinkedListDeque classes inherit from the Deque interface. ==从概念上讲，Deque是一个接口，ArrayDeque和LinkedListDeque是其实现。在代码中，为了表达这种关系，我们让ArrayDeque和LinkedListDeque类继承自Deque接口==。**

Some commonly used ADT's are:

- **Stacks: Structures that support last-in first-out retrieval of elements**
  - `push(int x)`: puts x on the top of the stack
  - `int pop()`: takes the element on the top of the stack
- **Lists : an ordered set of elements**
  - `add(int i)`: adds an element
  - `int get(int i)`: gets element at index i
- **Sets : an unordered set of unique elements (no repeats)**
  - `add(int i)`: adds an element
  - `contains(int i)`: returns a boolean for whether or not the set contains the value
- **==Maps== : set of key/value pairs**
  - `put(K key, V value)`: puts a key value pair into the map
  - `V get(K key)`: gets the value corresponding to the key

**The bolded ADT's are a subinterfaces of a bigger overarching interface called `Collections`

Below we show the relationships between the interfaces and classes. Interfaces are in white, classes are in blue.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203151550328.png" alt="image-20230203151550328" style="zoom:33%;" />

ADT's allow us to make use of object oriented programming in an efficient and elegant way. You saw in proj1b how we could swap `OffByOne` and `OffByN` comparators because they both implemented the same interface! In the same way, you can use an ArrayDeque or a LinkedListArrayDeque interchangeably because they are both part of the Deque ADT.ADT允许我们以高效和优雅的方式使用面向对象的编程。您在proj1b中看到了我们如何交换“OffByOne”和“OffByN”比较器，因为它们都实现了相同的接口！同样，**==您可以互换使用ArrayDeque或LinkedListArrayDeq，因为它们都是Deque ADT的一部分。==**

In the following chapters, we will work on defining some more ADT's and enumerating their different implementations.在接下来的章节中，我们将致力于定义更多的ADT并列举它们的不同实现。

# 10.2 Trees

## Binary Search Trees 二叉搜索树

> **==BST的名字由来 : 可以进行Binary Search(二叉搜索)==**

**Now we are going to learn about perhaps the most important data structure ever.**

Linked List很好，但搜索项目需要很长时间，即使列表已排序！如果该项目位于列表末尾，该怎么办？这需要线性时间！看看下面的链接列表，让自己相信这是真的。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203160032869.png" alt="image-20230203160032869" style="zoom:33%;" />

We know that for an array, we can use binary search to find an element faster. Specifically, in log(*n*) time. For a short explanation of binary search, check out this [link](https://www.geeksforgeeks.org/binary-search/).

But how do we run binary search for a linked list? We would have to traverse all the way to the middle in order to check the element there, which takes linear time just on its own!但是我们如何对链接列表进行二进制搜索呢？为了检查那里的元素，我们必须一直遍历到中间，这本身就需要线性时间！

One optimization we can implement is to have a reference to the middle node. This way, we can get to the middle in constant time. Then, if we flip the nodes' pointers, which allows us to traverse to both the left and right halves, we can decrease our runtime by half!我们可以实现的一个优化是**引用中间节点**。这样，我们可以在恒定的时间内到达中间。然后，如果我们翻转节点的指针，这允许我们遍历左半部分和右半部分，我们可以将运行时间减少一半！

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203160600605.png" alt="image-20230203160600605" style="zoom:33%;" />

> 这个过程不是CS61B的讨论内容, 他会需要`O(log(n))`的时间, 详情 : [Skip list - Wikipedia](https://en.wikipedia.org/wiki/Skip_list)

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203160430943.png" alt="image-20230203160430943" style="zoom: 33%;" />

But, we can do better than that. We can further optimize by adding pointers to the middle of each recursive half like so.但是，我们可以做得更好。**我们可以通过在每个递归半段的中间添加指针来进一步优化。**

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203160358261.png" alt="image-20230203160358261" style="zoom:33%;" />

Now, if you stretch this structure vertically, you will see a tree!现在，如果你垂直拉伸这个结构，你会看到一棵树！

==This specific tree is called a **binary tree** because each juncture splits in 2.这个特定的树被称为**二叉树**，因为每个节点都分裂为2。==

### Properties of trees 树的属性

Let's formalize the tree data structure a bit more.让我们将树数据结构形式化一点。

**Trees are composed of:**

- **nodes**
- **edges that connect those nodes.**
  - **Constraint**: there is only one path between any two nodes. **约束**：任意两个节点之间只有一条路径。

名词 :

+ root : 没有父节点的节点
+ leaf : 没有子节点的节点

将这与我们先前提出的原始树结构联系起来，我们现在可以在现有约束中引入新的约束。这将创建更具体类型的树，两个示例是二叉树和(Binary Trees)二叉搜索树(Binary Search Trees)。

- **Binary Trees**: in addition to the above requirements, also hold the binary property constraint. That is, each node has either 0, 1, or 2 children.除上述要求外，还保持二进制属性约束。也就是说，每个节点都有0、1或2个子节点。
- **Binary Search Trees**: in addition to all of the above requirements, also hold the property that For every node X in the tree: 除上述所有要求外，还应具有以下属性：对于树中的每个节点X：
  - ==**Every key in the left subtree is less than X’s key.**==左子树中的每个关键点都小于X的关键点。
  - **==Every key in the right subtree is greater than X’s key==**. **Remember this property!! We will reference it a lot throughout the duration of this module and 61B.**

Here is the BST class we will be using in this module:左子树中的每个关键点都小于X的关键点。

```java
private class BST<Key> {
    private Key key;
    private BST left;
    private BST right;

    public BST(Key key, BST left, BST Right) {
        this.key = key;
        this.left = left;
        this.right = right;
    }

    public BST(Key key) {
        this.key = key;
    }
}
```

## Binary Search Tree Operations

### Search

To search for something, we employ binary search which is made easy due to the BST property described in the previous section!

**Exercise 10.2.2:** Try to write this method by yourself. Here is the method header: `static BST find(BST T, Key key)`. It should return the BST rooted at the node whose key matched the key parameter.

```java
static BST find(BST T, Key sk) {
   if (T == null)
      return null;
   if (sk.equals(T.key)) //要用equals()而不是'==' !!!!!!!!!!!!!!!因为有可能会有不同的实现
      return T;
   else if (sk ≺ T.key)
      return find(T.left, sk);
   else
      return find(T.right, sk);
}
```

If our tree is relatively "bushy", **==the find operation will run in log(*n*) time because the height of the tree is logn, that's pretty fast!==**

### Insert

We **always** insert at a leaf node!

首先，我们在树中搜索节点。如果我们找到了，那么我们什么都不做。如果我们没有找到它，我们将已经处于叶节点。此时，我们只需将新元素添加到叶的左侧或右侧，即可保留BST属性。

**Exercise 10.2.3:** Try to write this method by yourself. Here is the method header: `static BST insert(BST T, Key ik)`. It should return the full BST with the new node inserted in the correct position.

```java
static BST insert(BST T, Key ik) {
  if (T == null)
    return new BST(ik);
  if (ik ≺ T.key)
    T.left = insert(T.left, ik);
  else if (ik ≻ T.key)
    T.right = insert(T.right, ik);
  return T;
}
```

> ==这个相对要难想出来, 递归的思想==

**Exercise 10.2.4:** 想象一下插入的顺序会导致树的高度不同。试着找出树高的两种极端情况。提示：您的第一次插入将决定以下插入的大部分行为。

> **==注意 : 这里的`≺`不是狭义的大于小于, 而是广义的"先于后于"==**

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203162728215.png" alt="image-20230203162728215" style="zoom:50%;" />

> **==尽可能地让basic situation只有一个!!!!!!!!!!==**
>
> ==arm length recursion : 总感觉和真正的有一定距离, 不敢写出BST(ik)==

### Delete

从二叉树中删除会有点复杂，因为无论何时删除，我们都需要确保重建树并保持其BST属性。

让我们将这个问题分为三类：

- the node we are trying to delete has no children
- has 1 child
- has 2 children

##### ==No children==

If the node has no children, it is a leaf, and we can just delete its parent pointer and the node will eventually be swept away by the [garbage collector](https://stackoverflow.com/questions/3798424/what-is-the-garbage-collector-in-java).

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203180822665.png" alt="image-20230203180822665" style="zoom: 25%;" />

##### ==One child==

如果节点只有一个子节点，我们知道该子节点与节点的父节点一起维护BST属性，因为该属性对右子树和左子树是递归的。因此，我们只需将父节点的子指针重新分配给节点的子节点，该节点最终将被垃圾收集。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203180954261.png" alt="image-20230203180954261" style="zoom:25%;" />

##### ==Two children==

如果节点有两个子节点，那么过程会变得稍微复杂一些，因为我们不能只将其中一个子节点指定为新根节点。这可能会破坏BST属性。

相反，我们选择一个新节点来替换已删除的节点。

我们知道，新节点必须：

- be > than everything in left subtree.
- be < than everything right subtree.

==**要查找这些节点，可以只取左子树中最右边的节点或右子树中最左边的节点。**==

This is called **==Hibbard deletion==**, and it gloriously maintains the BST property amidst a deletion.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203181609169.png" alt="image-20230203181609169" style="zoom: 22%;" /><img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203181631926.png" alt="image-20230203181631926" style="zoom:23%;" />

> **==因为可以保证"比任何一个都大" 或者 "比任何一个都小"==**

## BSTs as Sets and Maps

==We can use a BST to implement the `Set` ADT! But its even better because in an ArraySet, **we have worst-case *O*(*n*) runtime to run `contains`** because we need to search the entire set. However, **if we use a BST, we can decrease this runtime to log(*n*)** because of the BST property which enables us to use binary search!==

We can also make a binary tree into a map by having each BST node hold `(key,value)` pairs instead of singular values. We will compare each element's key in order to determine where to place it within our tree.

## Summary

Abstract data types (ADTs) are defined in terms of operations, not implementation.

Several useful ADTs:

- Disjoint Sets, Map, Set, List.
- Java provides Map, Set, List interfaces, along with several implementations.

We’ve seen two ways to implement a Set (or Map):

- **==ArraySet: Θ(*N*) operations in the worst case.==**
- **==BST: Θ(log*N*) operations if tree is balanced.==**

BST Implementations:

- **Search and insert are straightforward (but insert is a little tricky).**
- **Deletion is more challenging. Typical approach is “Hibbard deletion”.**

#### What Next

- [Lab 7](https://sp19.datastructur.es/materials/lab/lab7/lab7)
- [Discussion 7](https://sp19.datastructur.es/materials/discussion/disc07.pdf)

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203195551313.png" alt="image-20230203195551313" style="zoom: 25%;" />

