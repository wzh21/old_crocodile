# 11.1 Intro to Balanced Search Trees

## Binary Tree Height

**The difference in runtime between a worst-case tree and best-case tree is very dramatic.(在计算height时)**

**Worst case:** Θ(*N*)

**Best-case:** Θ(log*N*) (where *N* is number of nodes in the tree)

The runtimes are dependent on the structure of the tree. If the tree is really **spindly(**细长的), then its basically a linked list and the runtime is **linear**. If the tree is **bushy**, then the height of the tree is log*N* and therefore the runtime grows in **log*N* time**.

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203215203083.png" alt="image-20230203215203083" style="zoom: 25%;" />

### A short detour into BigO and worst case

BigO is **not** equivalent to worst case! Remember, BigO is an upper bound. As long as a function falls within that bound, it is considered to be inside the BigO of that function. Worst-case is more restrictive than BigO. ==**BigO不等于最坏情况！**记住，BigO是上限。只要一个函数位于该范围内，它就被认为位于该函数的BigO内。最坏的情况比BigO更严格。==

例如，考虑搜索酒店。如果你正在寻找一家最差情况为500美元客房的酒店，那么只有少数酒店符合这一要求，也许只有丽思卡尔顿酒店。另一方面，如果你在搜索O（500）或低于500美元房间的酒店，那么从Motel 6到Rodeway Inn到Ritz-Carlton，许多酒店都属于这一类别。

Thus, even though we said the worst-case runtime of a BST is Θ(*N*), it also falls under O*(*N^2).

==**Many people use BigO as shorthand for worst-case, but this is technically not synonymous.许多人使用BigO作为最坏情况的简写，但这在技术上并不是同义词!!!!** We want you guys to be cream-of-the-crop computer scientists, so we are making this distinction!==

## BST Performance

Some terminology(术语) for BST performance: 

- **depth**: the number of links between **==a node==** and the root.
- **height**: ==the lowest depth of a tree.==
- **average depth**: average of the total depths in the tree. You calculate this by taking <img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203214324548.png" alt="image-20230203214324548" style="zoom:33%;" />where <img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203214337515.png" alt="image-20230203214337515" style="zoom:33%;" /> is depth and <img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203214353304.png" alt="image-20230203214353304" style="zoom:33%;" /> is number of nodes at that depth.

==The **height** of the tree determines the worst-case runtime, because in the worst case the node we are looking for is at the bottom of the tree.==

==The **average depth** determines the average-case runtime.==

### BST insertion order

The order you insert nodes into a BST determines its height.

是的，具有特定的插入顺序可以帮助我们获得平衡的树。然而，我们甚至不需要那么刻意。如果我们只是按**随机**顺序插入节点，它实际上会变得相对浓密！

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203215412697.png" alt="image-20230203215412697" style="zoom: 25%;" />

你不必知道这一点的证明，但当我们随机插入BST时，**平均深度**和**高度**预计为Θ（logN）。

然而，我们不能总是以随机顺序插入BST。如果我们的数据是实时的呢？然后，我们将被迫按照数据到达的顺序插入。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203215433866.png" alt="image-20230203215433866" style="zoom:25%;" />

**In the next chapter we will learn about a tree that always maintains its balance!**

# 11.2 B-Trees

> ==**提出B-Tree的原因就是"尽可能让树bushy"!!!!!!!!!!!!!!!!!!!!!!!**==

The problem with BST's is that we always insert at a leaf node. 

**Crazy Idea**: let's just never add a leaf node! When we insert, let's just add to a current leaf node. This way, the height will never increase. ==**疯狂的想法**：让我们永远不要添加叶节点！==当我们插入时，让我们只添加到当前叶节点。这样，高度永远不会增加。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203223704266.png" alt="image-20230203223704266" style="zoom: 25%;" />

**Solution**: 设置单个节点中元素数量的限制。假设4。如果我们需要在一个节点已经有4个元素的情况下向它添加一个新元素，我们会将该节点一分为二。通过碰撞左中节点。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203223804352.png" alt="image-20230203223804352" style="zoom: 25%;" />

然后提出新的方案：设定节点最多容纳数据的数量，比如3，如果插入的数据数量超过三，则选择一个数据插入到父节点上。**但是这样做有一个问题，那就是并不满足开始二叉树的定义，即大于右子树的所有值。如上图，选择17加入父节点，17就会大于右子树的16。怎样解决？**

答案是变成3个children，加入一个中间节点。
<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203234627746.png" alt="image-20230203234627746" style="zoom:33%;" />

Notice that now the 15-17 node has 3 children now, and each child is either less than, between, or greater than 15 and 17. By keeping the children sorted, we can continue to use binary search.请注意，现在15-17节点有3个子节点，每个子节点都小于、介于或大于15和17。通过保持子级排序，我们可以继续使用二分搜索。

By splitting nodes in the middle, we maintain perfect balance! ==These trees are called **B-trees** or **2-3-4/2-3 Trees**. 2-3-4 and 2-3 refer to the number of children each node can have.== So, a 2-3-4 tree can have 2, 3, or 4 children while a 2-3 tree can have 2 or 3. This means that 2-3-4 trees split nodes when they have 3 nodes and one more needs to be added. 2-3 trees split after they have 2 nodes and one more needs to be added.

> ==这就是"B-Trees"的基本思想, 就是把节点的中间偏左的那个节点push up==

#### Insertion Process

The process of adding a node to a 2-3-4 tree is:

1. 我们仍然总是插入到叶节点中，所以取您要插入的节点，并沿着树向下遍历，根据要插入的结点是否大于或小于每个结点中的项，向左和向右移动。
2. 将节点添加到叶节点后，如果新节点有4个节点，则弹出左中的节点并相应地重新排列子节点。
3. 如果这导致父节点具有4个节点，则再次弹出左中节点，相应地重新排列子节点。
4. 重复此过程，直到父节点能够容纳或到达根节点。

For a 2-3 tree, go through the same process except push up the middle node in a 3-element node.

If you want some more practice, go through the exercises in these [slides](https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_584)

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203224534153.png" alt="image-20230203224534153" style="zoom: 25%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203224545075.png" alt="image-20230203224545075" style="zoom: 25%;" />

# 11.3 B-Tree invariants and runtime

## B-Tree invariants (不变量)

我们在第11.1章中提到，在插入BST时，顺序很重要。

**Question**: Is this also true for a B-Tree?

**Exercise 11.3.1**: Insert 1-7 into a B-tree in that order. What is the height of the tree? Can we change the order of the insertions so that we can decrease the height? Here is a [cool B-tree visualizer](https://www.cs.usfca.edu/~galles/visualization/BTree.html) might help!

**Solution**: Yes, we can get a tree of height 1 by inserting in this order: 2, 3, 4, 5, 6, 1, 7. 

Yes, depending on the order you insert nodes the height of a B-tree may change. However, the tree will always be **bushy.**

**==A B-tree has the following helpful invariants:==**

- **==All leaves must be the same distance from the source.==**
- **==A non-leaf node with *k* items must have exactly *k*+1 children.==**

---

由于B-Tree构造的规则，得到了两个Invariants。

1. 所有的leaf(底层节点）距离source（顶部）的距离是相同的。
2. 一个具有k个数据的节点拥有的子节点的数量一定是k+1

---

虽然不好证明，但是想一想肯定是对的。下面就分析复杂度了。

In tandem, these invariants cause the tree to always be bushy. 同时，这些不变量使树总是浓密的。

> ==We will soon prove: All operations have guaranteed O(log N) time.==

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203233922109.png" alt="image-20230203233922109" style="zoom:25%;" />

> 作者从未解释过“B树”的起源。正如我们将看到的，“平衡”、“广阔”或“浓密”可能适用。其他人认为“B”代表波音公司。然而，由于他的贡献，将B树视为“拜耳”树似乎是合适的。
>
> 这种数据结构就称之为B Tree。（意思可能是Balanced Tree，==但Josh觉得叫Split Tree更合适一些==）

## B-Tree runtime analysis

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230203233727399.png" alt="image-20230203233727399" style="zoom: 67%;" />

<img src="https://img-blog.csdnimg.cn/20200411222110981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvdXJpZXJfdHJhbnNmb3JtZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" />

如图，B-Tree高度最高时，每个节点只有一个数据，则每个节点有两个子节点。计算得到树的高度是log(N)。
B-Tree高度最低时，每个节点有L个数据，则每个节点有L+1个子节点，计算得到树的高度是logL+1(N)。
因此，B-Tree 的Overall Height是Θ(log N)。（log随便换底）

<img src="https://img-blog.csdnimg.cn/20200411223211340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvdXJpZXJfdHJhbnNmb3JtZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" />

计算好了高度，分析contain方法的复杂度很简单，为O(log N)

<img src="https://img-blog.csdnimg.cn/20200411223341731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvdXJpZXJfdHJhbnNmb3JtZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 33%;" />

add也一样。

## B-Tree deletion (Extra)

See [these extra slides](https://docs.google.com/presentation/d/1zhQDvbcDZ9RJgJl0bmqwFFlHP8ExbDFo36Q9ZWH9EgU/edit#slide=id.g508ece10b0_1_1305) if you're curious. We won't discuss them here.

### Summary

BSTs have best case height Θ(log*N*), and worst case height Θ(*N*).

- Big O is not the same thing as worst case!

B-Trees are a modification of the binary search tree that avoids Θ(*N*) worst case.

- Nodes may contain between 1 and L items.
- contains works almost exactly like a normal BST.
- add works by adding items to existing leaf nodes.
  - If nodes are too full, they split.
- Resulting tree has perfect balance. Runtime for operations is *O*(log*N*).
- Have not discussed deletion. See extra slides if you’re curious.
- Have not discussed how splitting works if L>3 (see some other class).
- B-trees are more complex, but they can efficiently handle ANY insertion order.



# 11.4 Rotating Trees

尽管它们非常平衡，但B树确实很难实现。我们需要跟踪不同的节点，拆分过程非常复杂。作为欣赏好代码和好挑战的计算机科学家，让我们找到另一种创建平衡树的方法。

## BST structure

对于任何BST，有多种方法来构造它，以便维护BST不变量。在第11.1章中，我们讨论了**以不同的顺序插入**元素将如何产生不同的BST。下面的BST都由元素1、2和3组成，但都具有不同的结构。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204113757398.png" alt="image-20230204113757398" style="zoom:33%;" />

**练习11.4.1**：对于上面显示的每一棵树，提供生成结构的插入顺序。

However, insertion is not the only way to yield different structures for the same BST. One thing we can do is change the tree with the nodes already in place through a process called **==rotating==**.然而，**插入并不是为同一个BST生成不同结构的唯一方法。**我们可以做的一件事是通过一个名为**旋转**的过程来更改树，使节点已经就位。

## Tree Rotation

**The formal definition of rotation is:**

```java
rotateLeft(G): Let x be the right child of G. Make G the new left child of x.
rotateRight(G): Let x be the left child of G. Make G the new right child of x.
```

我们将在接下来的几段中慢慢揭开这个过程的神秘面纱。以下是对节点G向左旋转时发生的情况的图形描述。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204113947263.png" alt="image-20230204113947263" style="zoom:33%;" />

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204114111189.png" alt="image-20230204114111189" style="zoom:33%;" />

G的右孩子P与G合并，带着它的孩子一起。然后，**P将其左边的孩子传递给G，G向下到左边成为P的左边的孩子**。您可以看到树的结构以及级别的数量发生了变化。**==我们也可以在非根节点上旋转。我们只需暂时断开节点与父节点的连接，旋转节点处的子树，然后重新连接新根。==**

Here are the implementations of `rotateRight` and `rotateLeft` courtesy of the [princeton docs]([https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html\](https://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html/)) with some lines omitted for simplicity.

```java
private Node rotateRight(Node h) {
    // assert (h != null) && isRed(h.left);
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    return x;
}

// make a right-leaning link lean to the left
private Node rotateLeft(Node h) {
    // assert (h != null) && isRed(h.right);
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    return x;
}
```

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204114820894.png" alt="image-20230204114820894" style="zoom:25%;" />

With rotations, we can actually completely balance a tree. See the demo in these slides: [demo](https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit#slide=id.g465b5392c_00)

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204114848959.png" alt="image-20230204114848959" style="zoom:25%;" />

在下一章中，我们将学习通过使用旋转保持平衡的特定树数据结构。



# 11.5 Red-Black Trees

我们在上一节中说过，我们非常喜欢2-3棵树，因为它们总是保持平衡，**==但我们也不喜欢它们，因为它们很难实现。==** But why not both？**==为什么不创建一个使用BST实现的树，但在结构上与2-3树相同，因此保持平衡==**？（请注意，**在本章中，我们将具体研究2-3棵树，而不是2-3-4棵树**）

**Enter the Red-Black Tree**

We are going to create this tree by looking at a 2-3 tree and asking ourselves what kind of modifications we can make in order to convert it into a BST.我们将通过查看2-3棵树来创建这棵树，并询问自己可以进行什么样的修改，以便将其转换为BST。

For a 2-3 tree that only has 2-nodes (nodes with 2 children), we already have a BST, so we don't need to make any modifications! 对于只有2个节点（节点有2个子节点）的2-3树，我们已经有了BST，因此不需要进行任何修改！

However, what happens when we get a 3-node?然而，当我们得到一个3节点时会发生什么？

One thing we could do is create a "glue" node that doesn't hold any information and only serves to show that its 2 children are actually a part of one node.我们可以做的一件事是创建一个“粘合”节点，该节点不包含任何信息，只用于显示其2个子节点实际上是一个节点的一部分。

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204115655153.png" alt="image-20230204115655153" style="zoom:33%;" />

However, this is a very inelegant solution because we are taking up more space and the code will be ugly. **So, instead of using glue nodes we will use glue links instead!** 然而，这是一个非常不优雅的解决方案，因为我们占用了更多的空间，代码会很难看。因此，我们将使用粘合链接，而不是使用粘合节点！

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204115746825.png" alt="image-20230204115746825" style="zoom:33%;" />

We choose arbitrarily to make the left element a child of the right one. This results in a **left-leaning** tree. We show that a link is a glue link by making it red. Normal links are black. Because of this, we call these structures **left-leaning red-black trees (LLRB)**. We will be using left-leaning trees in 61B.我们任意选择使左元素成为右元素的子元素。这会导致**向左倾斜**的树。我们通过将链接设置为红色来显示它是一个胶粘链接。正常链接是黑色的。因此，我们将这些结构称为**左倾红黑树（LLRB）**。我们将在61B使用向左倾斜的树木。

---

练习：

<img src="C:\Users\weiziheng\AppData\Roaming\Typora\typora-user-images\image-20230204120157047.png" alt="image-20230204120157047" style="zoom: 33%;" />

---

**Left-Leaning Red-Black trees have a 1-1 correspondence with 2-3 trees. Every 2-3 tree has a unique LLRB red-black tree associated with it. As for 2-3-4 trees, they maintain correspondence with standard Red-Black trees.向左倾斜的红黑树与2-3棵树有1-1的对应关系。每2-3棵树都有一棵独特的LLRB红黑树与其相关。至于2-3-4棵树，它们与标准红黑树保持一致。**

## Properties of LLRB's

Here are the properties of LLRB's:

- 1-1 correspondence with 2-3 trees.
- No node has 2 red links.
- There are no red right-links.
- Every path from root to leaf has same number of black links (because 2-3 trees have same number of links to every leaf).
- Height is no more than 2x height of corresponding 2-3 tree.

## Inserting into LLRB

We can always insert into a LLRB tree by inserting into a 2-3 tree and converting it using the scheme from above. However, this would be contrary to our original purpose of creating a LLRB, which was to avoid the complicate code of a 2-3 tree! Instead, we insert into the LLRB as we would with a normal BST. However, this could break its 1-1 mapping to a 2-3 tree, so we will use rotations to massage the tree back into a proper structure.

We will go over the different tasks we need to address when inserting into a LLRB below.

1. **Task 1: insertion color**: because in a 2-3 tree, we are always inserting by adding to a leaf node, the color of the link we add should always be red.

2. **Task 2: insertion on the right**: recall, we are using *left-leaning* red black trees, which means we can never have a right red link. If we insert on the right, we will need to use a rotation in order to maintain the LLRB invariant.![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.14.41%20PM.png)
   However, if we were to insert on the right with a red link and the left child is *also* a red link, then we will temporarily allow it for purposes that will become clearer in task 3.

   ![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.33.14%20PM.png)

3. **Task 3: double insertion on the left:** If there are 2 left red links, then we have a 4-node which is illegal. First, we will rotate to create the same tree seen in task 2 above. ![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.36.00%20PM.png)Then, in both situations, we will flip the colors of all edges touching S. This is equivalent to pushing up the middle node in a 2-3 tree.

![img](https://joshhug.gitbooks.io/hug61b/content/assets/Screen%20Shot%202019-03-06%20at%2011.37.57%20PM.png)

You may need to go through a series of rotations in order to complete the transformation. The process is: while the LLRB tree does not satisfy the 1-1 correspondence with a 2-3 tree or breaks the LLRB invariants, perform task 1, 2, or 3 depending on the condition of the tree until you get a legal LLRB.

Here is a summary of all the operations:

- When inserting: Use a red link.
- If there is aright leaning “3-node”, we have a Left Leaning Violation
  - Rotate left the appropriate node to fix.
- If there are two consecutive left links, we have an incorrect 4 Node Violation!
  - Rotate right the appropriate node to fix.
- If there are any nodes with two red children, we have a temporary 4 Node.
  - Color flip the node to emulate the split operation.

## Runtime

Because a left-leaning red-black tree has a 1-1 correspondence with a 2-3 tree and will always remain within 2x the height of its 2-3 tree, the runtimes of the operations will take log�log*N* time.

Here's the abstracted code for insertion into a LLRB:

```java
private Node put(Node h, Key key, Value val) {
    if (h == null) { return new Node(key, val, RED); }

    int cmp = key.compareTo(h.key);
    if (cmp < 0)      { h.left  = put(h.left,  key, val); }
    else if (cmp > 0) { h.right = put(h.right, key, val); }
    else              { h.val   = val;                    }

    if (isRed(h.right) && !isRed(h.left))      { h = rotateLeft(h);  }
    if (isRed(h.left)  &&  isRed(h.left.left)) { h = rotateRight(h); }
    if (isRed(h.left)  &&  isRed(h.right))     { flipColors(h);      } 

    return h;
}
```

Look how short and sweet!

## Summary

- Binary search trees are simple, but they are subject to imbalance which leads to crappy runtime.
- 2-3 Trees (B Trees) are balanced, but painful to implement and relatively slow.
- LLRBs insertion is simple to implement (but deletion is hard).
  - Works by maintaining mathematical bijection with a 2-3 trees.
- Java’s [TreeMap](https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/java.base/share/classes/java/util/TreeMap.java) is a red-black tree (but not left leaning).
- LLRBs maintain correspondence with 2-3 tree, Standard Red-Black trees maintain correspondence with 2-3-4 trees.
- Allows glue links on either side (see [Red-Black Tree](http://en.wikipedia.org/wiki/Red–black_tree)).
- More complex implementation, but significantly faster.